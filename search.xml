<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Algebra Chapter 0 - 1.5 Univeral Properties</title>
    <url>/2022/01/17/Algebra-Chapter-0-1-5-Univeral-Properties/</url>
    <content><![CDATA[<h3 id="§5-1-Initial-and-final-objects"><a class="header-anchor" href="#§5-1-Initial-and-final-objects">¶</a>§5.1 - Initial and final objects</h3>
<h4 id="Definition-5-1"><a class="header-anchor" href="#Definition-5-1">¶</a>Definition 5.1</h4>
<ul>
<li>
<p>Let $\mathsf{C}$ be a category. Then object $I$ of $\mathsf{C}$ is <strong>$initial$</strong> if for every object $A$ of $\mathsf{C}$ there exists <strong>exactly one</strong> morphism $I\rightarrow A$ in $\mathsf{C}$:</p>
<p>$\begin{align}\forall A \in \mathsf{Obj©}:\mathsf{Hom_C}(I,A)\end{align}$ is a singleton.</p>
<span id="more"></span>
</li>
<li>
<p>An object $F$ of $\mathsf{C}$ is $final$ in $\mathsf{C}$ if for every object $A$ of $C$ there exists <strong>exactly one</strong> morphism $A\rightarrow F$ in $\mathsf{C}$:</p>
<p>$\begin{align}\forall A\in \mathsf{Obj©}:\ \mathsf{Hom_C}(A,F)  \end{align}$ is a singleton.</p>
</li>
</ul>
<h4 id="Proposition-5-4"><a class="header-anchor" href="#Proposition-5-4">¶</a>Proposition 5.4</h4>
<ul>
<li>$I_1,I_2\ are\ both\ inital\ objects\Rightarrow I_1\cong I_2$.</li>
<li>$F_1,F_2\ are\ both\ final\ objects\Rightarrow F_1\cong F_2$.</li>
</ul>
<h3 id="§5-2-Universal-Properties"><a class="header-anchor" href="#§5-2-Universal-Properties">¶</a>§5.2 Universal Properties</h3>
<ul>
<li>We say that a construction satisfies a universal property when it may be viewed as a terminal object of a category. More often, the situation is complex and the ‘explanation’ of a universal property may follow the pattern, “object $X$ is universal with respect to the following property: for any $Y$ such that $\dots$ , there exists a unique morphism $Y\rightarrow X$ such that $\dots$ .”</li>
</ul>
<h3 id="§5-3-Quotients"><a class="header-anchor" href="#§5-3-Quotients">¶</a>§5.3 Quotients</h3>
<ul>
<li>
<p>“The quotient $A/\sim$  is universal with respect to the property of mapping $A$ to a set in such a way that equivalent elements have the same image.”</p>
</li>
<li>
<p>The assertion above is talking about functions $A\stackrel{\phi}{\longrightarrow} Z$ with $Z$ any set, satisfying the property: $a’\sim a’‘\rightarrow \phi(a’)=\phi(a’')$. These morphisms are objects of a category; for convenience, let’s denote such an object by $(\phi,Z)$. The only reasonable way to define morphisms $(\phi_1,Z_1)\rightarrow(\phi_2,Z_2)$ is as commutative diagrams</p>
<p><img src="/2022/01/17/Algebra-Chapter-0-1-5-Univeral-Properties/image-20220117215734905.png" alt></p>
</li>
</ul>
<h3 id="§5-4-Products"><a class="header-anchor" href="#§5-4-Products">¶</a>§5.4 Products</h3>
<ul>
<li>
<p>Let $A$, $B$ be sets, and consider the product $A\times B$, with the two partial projections:</p>
<p><img src="/2022/01/17/Algebra-Chapter-0-1-5-Univeral-Properties/Algebra-Chapter-0-1-5-Univeral-Properties%5Cimage-20220303222022906.png" alt></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Algebra Chapter 0</tag>
      </tags>
  </entry>
  <entry>
    <title>Algebra Chapter 0 - 1.3 Categories</title>
    <url>/2021/12/10/Algebra-Chapter-0-1-3-Categories/</url>
    <content><![CDATA[<h4 id="Definition-3-1-0"><a class="header-anchor" href="#Definition-3-1-0">¶</a>Definition 3.1.0</h4>
<p>​	A $category$ $\mathsf{C}$ consists of:</p>
<ul>
<li>
<p>a class $\mathrm{Obj}(\mathsf{C})$ of $objects$ of the category</p>
</li>
<li>
<p>for every two objects $A,B$ of $\mathsf{C}$ , a set $\mathrm{Obj}_{\mathsf{C}}(A,B)$ of $morphisms$ , with the properties listed below.</p>
<span id="more"></span>
</li>
</ul>
<p>​	Defining properties of morphisms:</p>
<ul>
<li>For every object $A$ of $\mathsf{C}$ , there exists (at least) one morphism $1_A\in \mathrm{Hom}_\mathsf{C}(A,B)$ , the ‘identity’ on $A$.</li>
<li>$\mathrm{Hom}<em>\mathsf{C}(A,B)\times\mathrm{Hom}</em>\mathsf{C}(B,C)$$=\mathrm{Hom}_\mathsf{C}(A,C)$.</li>
<li>Composition Law: $(hg)f=h(gf)$.</li>
<li>For all $f\in \mathrm{Hom}_\mathsf{C}(A,B)$ , we have $f1_A=1_Bf=f$.</li>
</ul>
<h4 id="Definition-3-1-1"><a class="header-anchor" href="#Definition-3-1-1">¶</a>Definition 3.1.1</h4>
<p>​	$\mathrm{End}<em>\mathsf{C}(A)=\mathrm{Hom}</em>\mathsf{C}(A,A)$.</p>
<h4 id="Example-3-1"><a class="header-anchor" href="#Example-3-1">¶</a>Example 3.1</h4>
<p>​	Consider category $\mathsf{C}$ , and let $A$ be an object of $\mathsf{C}$ . We define a category $\mathsf{C}_A$ whose objects are certain morphisms in $\mathsf{C}$ : $\mathrm{Obj}(\mathsf{C}<em>A)=all\ morphisms\ from\ $$any\ object\ of\ \mathsf{C}\ to\ A$ . Pictorially, an object in $\mathsf{C}</em>{A}$ is an arrow $Z\stackrel{f}{\rightarrow}A$ .</p>
<p>​	Suppose $Z_1\stackrel{f_1}{\longrightarrow}A$ and $Z_2\stackrel{f_2}{\longrightarrow}A$ , morphisms $f_1\rightarrow f_2$ are defined to be commutative diagrams shown below.</p>
<p><img src="/2021/12/10/Algebra-Chapter-0-1-3-Categories/Gr_1" alt></p>
<p>​	The composition of morphisms in $\mathsf{C}$ can be verified without difficulty. Categories constructed in this pattern is called $slice \  category$ , which is a special form of $comma\ category$ .</p>
<h4 id="Example-3-2"><a class="header-anchor" href="#Example-3-2">¶</a>Example 3.2</h4>
<p>​	An similar example of <strong>Example 3.1</strong> can be obtained by considering morphisms in a category $\mathsf{C}$ from a fixed object $A$ to all objects in $\mathsf{C}$, with morphisms defined by suitable commutative diagrams. The category defined above is called $coslice\ category$.</p>
<h4 id="Example-3-3"><a class="header-anchor" href="#Example-3-3">¶</a>Example 3.3</h4>
<p>​	An example of coslice category is shown by letting $\mathsf{C=Set}$ and $A=$ a fixed singleton $\mathbb{S}$. We call this category $\mathsf{Set^*}$.</p>
<p>​	An object in this category is a morphism $f:\mathbb{S}\rightarrow S$ in $\mathsf{Set}$ where $S$ is any set. The information of ab object in $\mathsf{Set^<em>}$ consists of the choice of a nonempty set $S$ and an element $s\in S$ which is the element $f(</em>)$. Thus we may denote objects in this category as pairs $(S,s)$. A morphism between two such objects, $(S,s)\rightarrow(T,t)$, corresponds to a set function $\sigma:S\rightarrow T$ such that $\sigma(s)=t$.</p>
<p>​	Objects of $\mathsf{Set}^*$ are called ‘pointed sets’ and many structures are pointed sets. For example, <strong>group homomorphisms</strong> sends one identity to another.</p>
]]></content>
      <tags>
        <tag>Algebra Chapter 0</tag>
      </tags>
  </entry>
  <entry>
    <title>BUAA OO U1 Review</title>
    <url>/2022/03/22/BUAA-OO-U1-Review/</url>
    <content><![CDATA[<h1>BUAA OO 第一单元总结</h1>
<h2 id="第一次作业"><a class="header-anchor" href="#第一次作业">¶</a>- 第一次作业</h2>
<p>​		第一次作业要求化简一个一元（变量只能为 $x$）的表达式，其中可以出现空白符和连续的正负号，至少需要去掉所有括号。为了得到性能分，还需要进行合并同类项的操作。</p>
<span id="more"></span>
<h3 id="程序架构"><a class="header-anchor" href="#程序架构">¶</a>程序架构</h3>
<p><img src="/2022/03/22/BUAA-OO-U1-Review/image-20220303222022906.png" alt></p>
<p><em>（一些类的 get 和 set 方法没有明确标出）</em></p>
<p>​		第一次作业采用了递归下降的处理方法，各个类的作用如下：</p>
<ul>
<li>
<p><strong>Element</strong>：使用 <code>HashMap&lt;Integer,BigInteger&gt;</code> 存储各个元素的信息，其中 Key 表示次数，Value 表示系数。由于第一次作业不包含任何其他特殊函数，所以无论是因子、项还是表达式都可以用 Element 来存储，结构比较统一，方便运算和化简。</p>
<p>为方便叙述，给出因子、项和表达式的定义：</p>
<ul>
<li><b> 因子 </b>：（+/-）变量的幂 + 常数的幂 + 括号表达式的幂（其中幂次为 1 可以省略幂指数）</li>
<li><b> 项 </b>：因子的乘积</li>
<li><b> 表达式 </b>：项的加和</li>
</ul>
</li>
<li>
<p><strong>Token</strong>：存储表达式基本单元的类，如操作符、括号、操作数和变量。</p>
</li>
<li>
<p><strong>Lexer</strong>：对输入表达式进行词法分析的类，将字符串分割为若干 token 并存入 <code>ArrayList&lt;Token&gt;</code>，并且在读入过程中进行初步化简：</p>
<ul>
<li>将连续的一串加减号划归为一个加 / 减号。</li>
<li>对于操作数直接用字符串存储，在后续处理过程中可以直接使用转换为整数。</li>
</ul>
</li>
<li>
<p><strong>Parser</strong>：递归下降逐个解析 <code>ArrayList&lt;Tokens&gt;</code> 的元素。<code>glbPos</code> 表示 token 的位置，<code>isHigh () isMid () isLow ()</code> 方法判断此时的 token 是否代表运算符并判断优先级。递归下降的入口是 <code>parseExpr ()</code>，之后进入 <code>parseTerm ()</code> 和 <code>parseUnit ()</code>，再从 <code>parseUnit ()</code> 调用 <code>parseExpr ()</code> 实现递归下降。由于结构统一，因此每个 parse 方法的返回类型都是 Element。</p>
</li>
</ul>
<h3 id="基于度量的结构分析"><a class="header-anchor" href="#基于度量的结构分析">¶</a>基于度量的结构分析</h3>
<p><img src="/2022/03/22/BUAA-OO-U1-Review/image-20220322123607798.png" alt></p>
<p>​	根据 CogC 指标排序，可以发现认知复杂度较高的方法为 <code>parseUnit ()</code> 和 <code>output ()</code>。</p>
<p>​	<code>parseUnit ()</code> 方法复杂度较高的原因是因子的定义比较多，需要判断类型和是否有乘方，导致其中出现很多判断分支；<code>output ()</code> 的原因类似，也是出现了很多分支来判断如何输出字符串。</p>
<h3 id="bug-分析"><a class="header-anchor" href="#bug-分析">¶</a>bug 分析</h3>
<p>​	本次作业的 bug 出现在形式化定义上。一开始我把因子定义为变量的幂 + 常数 + 表达式的幂，可以注意到这里缺少了常数的幂，于是输入 <code>x*2**2</code> 获得的结果就为 <code>4*x**2</code>，因为程序把 <code>x*2</code>parse 成了一个整体，于是在强测中出现了 bug。在 <code>parseUnit ()</code> 方法中添加一个判断即可解决。</p>
<h2 id="第二次作业"><a class="header-anchor" href="#第二次作业">¶</a>- 第二次作业</h2>
<p>​		第二次作业在第一次作业的基础上增加了三角函数（括号内只能是非负整数和 $x$ 的非负整数幂）、自定义函数和求和函数，依然要求去除不必要的括号并展开所有自定义函数和求和函数。本次作业的函数不能嵌套。</p>
<h3 id="程序架构-v2"><a class="header-anchor" href="#程序架构-v2">¶</a>程序架构</h3>
<p><img src="/2022/03/22/BUAA-OO-U1-Review/image-20220322162937182.png" alt></p>
<p><em>（一些类的 get 和 set 方法没有明确标出）</em></p>
<p>​		第二次作业仍然保持了递归下降的处理思路，因为找到了可以统一存储表达式各个部分的数据结构，感觉并没有重构的必要。<s>（其实是偷懒）</s></p>
<ul>
<li>
<p><strong>Poly</strong>：这里我将项定义为：<br>
$$<br>
\begin {align} a*({x^{b} }<em>\prod_{i=0}<sup>{\infty} {sin</sup>{s_i}(S_i)}</em>\prod_{j=0}<sup>{\infty} {cos</sup>{c_i}(C_j))} \end {align}<br>
$$<br>
而 Poly 则存储了最外层括号里面的内容，$b$ 对应 <code>exp</code>，<code>sinSet</code> 和 <code>cosSet</code> 分别对应两个累乘。<code>HashMap&lt;String,BigInteger&gt;</code> 中的 <code>String</code> 记录的是 $S_i$，因为本次作业三角函数中只能是 $x^p\ (p\ge0)$ 或者 $t\ (t\ge0,t\in \mathbb {Z})$，因此格式是完全确定且唯一的，可以用字符串存储。而且因子和项都可以用这种形式处理，这使得计算方面更加简便。</p>
</li>
<li>
<p><strong>Element</strong>：<code>HashMap&lt;Poly,BigInteger&gt;</code> 表示了 <code>Poly</code> 和系数 $a$ 的对应关系集合，即许多项的和。</p>
<p>其中包含了两个化简的方法，分别是特殊处理 $sin (0)/cos (0)$ 和处理三角函数平方和。</p>
</li>
<li>
<p><strong>PreProcessing</strong>：这个类用来处理自定义函数和求和函数，并且把第一次作业中出现的一些化简步骤整合了进来。下面简要说明如何处理两种函数。</p>
<ul>
<li>
<p><b> 自定义函数 </b>：</p>
<ul>
<li>读入自定义函数的定义，根据等号划分为左右两部分，分别为 <code>defL</code> 和 <code>defR</code>，使用正则匹配的捕获组来捕获 <code>defL</code> 的函数名以及变量（按顺序）。注意在此之前需要得到此函数变量的数量，然后使用特定的 Pattern 来匹配（我定义了一个 Pattern 数组，用来存放不同变量数量的 <code>defL</code> 正则表达式）。</li>
<li>当在输入中找到自定义函数（记为 <code>input</code>）的时候进行第二次正则匹配 &amp; 捕获（注意要找对函数名），按顺序获得需要代入的表达式，这样 <code>input</code> 和 <code>defL</code> 中参变量和实际表达式就以捕获组的序号进行了一一对应，方便处理如 $f (y,x)=y-x$ 等参变量不按顺序出现的自定义函数。</li>
<li>读取 <code>defR</code>，将参变量替换为对应需要代入的表达式即可（记得在每个代入的表达式外套一层括号来表示这是一个整体，防止替换回去之后产生错误），这里需要注意的一点是如果先进行了 $y$ 或者 $z$ 的替换而参变量中有 $x$，那么在将 $y$ 替换为含 $x$ 的表达式之后可能会重复替换 $x$（比如 $f (y,x)=y-x$，<code>input</code> 为 $f (x,x+1)$，那么替换过程就是 $y-x\rightarrow x-x\rightarrow (x+1)-(x+1)\rightarrow 0$，这显然是不正确的）。这里我的解决方法是：在替换的时候都把 $x$ 替换为不相关的字符 $w$，最后再统一 <code>replaceAll (&quot;w&quot;,&quot;x&quot;)</code> 即可。</li>
</ul>
<p>在处理自定义函数的时候，助教一再强调不要暴力字符串替换，而是 <b> 先对表达式进行建模，再代入原式 </b> ，奈何我没有想到很好的建模方法，于是只是使用了暴力替换。不过如果用表达式树处理的话建模会方便很多，可以先对各个表达式建一棵树，代入的时候替换掉上面的节点再插入原来的表达式树即可。</p>
</li>
<li>
<p><b> 求和函数 </b>：也是使用了字符串替换的方法，通过循环 + StringBuilder 构建需要替换的字符串。这里有三个需要注意的点：</p>
<ul>
<li>$sin$ 中也包含字母 i，替换的时候要小心。可以先把三角函数名提前换为 s&amp;c 来解决。</li>
<li>如果求和上限小于下限，则本项应为 0。</li>
<li>求和上下限最好定义为 <code>BigInteger</code> 类型防止溢出。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Lexer&amp;Parser&amp;Token</strong>：和第一次作业基本相同。</p>
</li>
</ul>
<h3 id="基于度量的结构分析-v2"><a class="header-anchor" href="#基于度量的结构分析-v2">¶</a>基于度量的结构分析</h3>
<p><img src="/2022/03/22/BUAA-OO-U1-Review/image-20220322174205046.png" alt></p>
<p>​		根据 CogC 指标排序发现，认知复杂度较高的方法前两位仍然是 <code>parseUnit ()</code> 和 <code>output ()</code>，这是更复杂的因子定义和更复杂的输出逻辑造成的。此外一些化简方法的复杂度也较高。</p>
<h3 id="bug-分析-v2"><a class="header-anchor" href="#bug-分析-v2">¶</a>bug 分析</h3>
<p>​		本次作业在强测和互测中都没有出现 bug，不过强测中一些点的性能分不高，这是因为我用原始的字符串来存储三角函数的内容，处理 $sin (0)/cos (0)$ 的化简时只考虑到字符串内容为 “0” 而忽视了 $sin (-0)$、$cos (+0)$ 等，造成没有化简完全的情况。</p>
<h2 id="第三次作业"><a class="header-anchor" href="#第三次作业">¶</a>- 第三次作业</h2>
<p>​		第三次作业在第二次作业的基础上允许了自定义函数的嵌套（求和函数内不允许出现自定义函数），同时三角函数内可以为表达式。</p>
<h3 id="程序架构-v3"><a class="header-anchor" href="#程序架构-v3">¶</a>程序架构</h3>
<p><img src="/2022/03/22/BUAA-OO-U1-Review/image-20220322175955155.png" alt></p>
<p><em>（一些类的 get 和 set 方法没有明确标出）</em></p>
<p>​		第三次作业在第二次作业的基础上只需要改动很少就可以，所以保持了原来的架构。其中最核心的改动是将 Poly 中存储三角函数的结构改为 <code>HashMap&lt;Element,BigInteger&gt;</code>，并～（差不多）~ 重写了 Poly 和 Element 的 <code>equals ()</code> 方法。</p>
<p>​		但是如果想要化简结果，则需要耗费很多时间来完善代码和测试。我花了大概两天时间才基本完成大概化简方法，其中有无数次测试 $\rightarrow$ 发现 bug$\rightarrow$ 修改代码 $\rightarrow$ 测试的循环😭。最核心的是三角函数平方和的化简，大致的逻辑为：</p>
<ul>
<li>遍历 Element 的 <code>HashMap</code>，看是否同时有两个不同的项，其中一个 $sin$ 的次数大于等于 2，另一个 $cos$ 的次数大于等于 2，并且其中包含的内容相同（<b> 这里需要重写 <code>equals ()</code> 方法 </b>，我自己另外写了一个 <code>equal ()</code> 来替代，这是不明智的做法）。其中内容相同的第一要素是三角函数中 Element 的 <code>HashMap</code> 的大小相同，所以需要在每次运算之后进行一次同类项合并。</li>
<li>判断这两项在分别将第一步找出来的 $sin$ 和 $cos$ 次数减去 2 之后，剩下的部分是否相同，如果相同，则把 $cos$ 那项的系数减过去，而它自己丢掉一个 $cos^2$。比如 $$x<em>sin^3 (x+1)+2</em>cos^2 (x+1)<em>x</em>sin (x+1)$$ 化简为 $$-x<em>sin^3 (x+1)+x</em>sin (x+1)$$ ，本质上就是作了 $cos^2 P=1-sin^2 P$ 的替换，虽然不是每个表达式都能完全化简，不过在相当一部分测试样例中都是奏效的。</li>
</ul>
<p>​		<b> 这里一个重要的点是深拷贝 / 浅拷贝的区别，比如第二步去掉 $cos^2$ 只需浅拷贝，直接修改 <code>this</code> 的 Poly 就可以，但是第一步中判断” 包含的内容相同 “时，不能真的分别去掉 $sin^2$ 和 $cos^2$，而是需要复制一份独立的副本（不是引用同一个地址的数据，而是两块独立的内存空间，其中的内容相同），为此可以直接写一个 <code>copy ()</code> 方法来复制，也可以用序列化方法来实现深拷贝（具体实现原理可以上网搜索）。</b></p>
<p>附序列化实现深拷贝的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialCloneable</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>,<span class="title">Serializable</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">try</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="comment">//save the object to a byte array  </span></span><br><span class="line">            ByteArrayOutputStream bout = <span class="keyword">new</span> ByteArrayOutputStream ();  </span><br><span class="line">            ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream (bout);  </span><br><span class="line">            out.writeObject (<span class="keyword">this</span>);  </span><br><span class="line">            out.close ();  </span><br><span class="line"></span><br><span class="line">            <span class="comment">//read a clone of the object from the byte array  </span></span><br><span class="line">            ByteArrayInputStream bin = <span class="keyword">new</span> ByteArrayInputStream (bout.toByteArray ());  </span><br><span class="line">            ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream (bin);  </span><br><span class="line">            Object result = in.readObject ();  </span><br><span class="line">            in.close ();  </span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception e)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;    </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基于度量的结构分析-v3"><a class="header-anchor" href="#基于度量的结构分析-v3">¶</a>基于度量的结构分析</h3>
<p><img src="/2022/03/22/BUAA-OO-U1-Review/image-20220322182027486.png" alt></p>
<p>​		根据分析数据可知，认知复杂度较高的方法主要是化简和输出。本次作业中 <code>parseUnit ()</code> 方法被拆分了，所以复杂度有所降低。</p>
<h3 id="bug-分析-v3"><a class="header-anchor" href="#bug-分析-v3">¶</a>bug 分析</h3>
<p>​		本次作业出现了一些 bug，分析如下：</p>
<ul>
<li>由于自定义函数允许嵌套，使用正则表达式捕获组处理输入的表达式会出现错误：
<ul>
<li><b> 正则表达式不能进行括号的匹配 </b>，可能会在嵌套的函数中间进行截断，导致程序结果错误甚至报错。</li>
<li><b> 解决方法 </b>：自行实现自定义函数内部表达式的括号匹配，等价于自己重新写了一个” 更加智能 “的捕获组。</li>
</ul>
</li>
<li>三角函数输出格式错误：
<ul>
<li><b><code>output ()</code> 调用的 <code>needBracket ()</code> 方法逻辑有误 </b> ，一些情况下会少输出一对三角函数内的括号，比如应该输出 $sin ((5<em>cos (x)))$ 而只输出了 $sin (5</em>cos (x))$。</li>
<li><b> 解决方法 </b>：调整 <code>needBracket ()</code> 内部的逻辑。</li>
</ul>
</li>
</ul>
<h2 id="hack-策略"><a class="header-anchor" href="#hack-策略">¶</a>- hack 策略</h2>
<p>​		下载其他同学的代码更多是为了学习架构（毕竟也没有自动评测机 + 没有发现细枝末节的 bug），因此在第一单元的互测中我并没有查看很多同学的代码，更多还是提交边缘数据和测试中出现 bug 的数据。</p>
<h2 id="架构设计评价"><a class="header-anchor" href="#架构设计评价">¶</a>- 架构设计评价</h2>
<p>​		三次作业的架构给我最大的印象就是：<b> 居然没有使用接口和继承 </b>。</p>
<p>​		其实第一单元作业并没有给我一种逐渐摸索架构的感觉，因为从第一次作业使用 <code>HashMap</code> 处理各种元素之后，第二次作业我的第一个思路就是：如何填充 <code>HashMap</code> 来继续保持结构的统一性。于是后来增加的 Poly 类就不能算是架构很大的调整，无非是细枝末节的完善以迎合新的需求，最后的第三次作业也可以说完全继承了第一次作业的架构。</p>
<p>​		可能是因为找到了一个统一的数据结构来存储因子、项和表达式，我没有再对项目进行细化处理。所有的计算都包含在 Element 和 Poly 类中；所有的表达式整体化简都在 PreProcessing 类中；所有的词法语法分析都包含在 Lexer 和 Parser 类中，相互之间的依赖关系比较浅，一个类处理完后交给另一个类。总体来说类之间的耦合程度很低，每个类基本上在各司其职，内聚程度比较高。</p>
<p>​		但是我认为这种架构的可扩展性不够，并且没有很好遵守” 对新增开放、对修改关闭 “的编程原则。可以发现从第一次到第三次作业的过程中，Element 类在不断膨胀，虽然后两次中添加了 Poly 来” 分担 “处理表达式的职能，但是仍然不是一个很好的解决方案。如果后续还有第四次甚至第五次迭代，这个架构有两种结果：要么膨胀到复杂度极高的状态，要么只能推倒重构。如果想要提高可扩展性，可以将 Element 和 Parser 拆开，增加其他的表达式元素类并使用接口。</p>
<h2 id="心得体会"><a class="header-anchor" href="#心得体会">¶</a>- 心得体会</h2>
<p>​		面向对象第一单元到这里就告一段落了，在本学期开始之前，我对 OO 的设想是：无非只是学一门新语言而已，但是这一单元带给我的绝不止熟悉 Java 的语法那么简单。面向对象不只是一种编程思想，还是一种理解世界的抽象化思维，它更加贴近人们平常认识事物的方式，并且便于迭代开发（这一单元使用面向过程恐怕最多可以通过第一次作业）。无论是对未来的程序设计还是对认识世界的思维方式，面向对象思想都大有可用之处。</p>
]]></content>
      <tags>
        <tag>BUAA OO</tag>
      </tags>
  </entry>
  <entry>
    <title>BUAA OO U2 Review</title>
    <url>/2022/05/26/BUAA-OO-U2-Review/</url>
    <content><![CDATA[<h1>🛰BUAA OO 第二单元总结</h1>
<h2 id="✍第五次作业"><a class="header-anchor" href="#✍第五次作业">¶</a>✍第五次作业</h2>
<h3 id="🏠程序架构"><a class="header-anchor" href="#🏠程序架构">¶</a>🏠程序架构</h3>
<p><strong>（UML 类图中省略了一些不重要的 <code>getter&amp;setter</code> 方法和构造方法，下同）</strong></p>
<span id="more"></span>
<p><img src="/2022/05/26/BUAA-OO-U2-Review/BUAA-OO-U2-Review%5CU2A1.png" alt></p>
<h4 id="💬重要类描述-调度器设计"><a class="header-anchor" href="#💬重要类描述-调度器设计">¶</a>💬重要类描述 + 调度器设计</h4>
<p>🤐 <strong><code>RequestQueue</code></strong>：</p>
<p>​		第一次作业对于 <code>Request</code> 的处理比较常规，就是和大部分同学一样写了线程安全类 <code>RequestQueue</code> 以保证重要结构被多线程同时访问时的数据安全。内部包含 <code>ConcurrentLinkedQueue&lt;PersonRequest&gt;</code> 作为请求载体，直接包装其自带的线程安全方法（<code>poll ()</code>、<code>peek ()</code> 和 <code>remove ()</code> 等等）即可。线程安全的数据结构除此之外还有 <code>ArrayBlockingQueue</code>、<code>ConcurrentHashMap/ConcurrentHashSet</code>、<code>Vector</code> 和 <code>CopyOnWriteArrayList</code> 等等，可以满足绝大部分的需要了。</p>
<p>🤐 <strong><code>Elevator</code></strong>：</p>
<p>​		电梯的功能的实现我采用了状态模式，因为电梯在这里只有四种状态：** 开门、关门、移动、等待 **，并且其之间的转换都遵循严格的条件，于是电梯可以拥有一个 <code>State</code> 接口字段，在状态转换的时候用 <code>setter</code> 方法切换一个 <code>new StateXXX ()</code>，并调用其中的方法 <code>behave ()</code> 的实现即可。一开始准备使用工厂模式来新建电梯的，但是由于本次作业对新增电梯没有考察且运行的电梯只有一种，所以为了简便就暂时搁置。</p>
<p>🤐 <strong><code>InputHandler &amp; RequestDispatcher</code></strong>：</p>
<p>​		这两个类共同持有一个 <code>RequestQueue</code> 对象 <code>waitQueue</code>，表示等待队列。<code>InputHandler</code> 从输入中获取的 <code>Request</code> 被首先放入此队列等待，然后 <code>RequestDispatcher</code> 根据请求的楼座分配给对应的电梯即可。在此过程中要注意共享对象的线程安全问题并使用 <code>notifyAll ()</code> 及时唤醒等待在此对象上的线程。<code>RequestDispatcher</code> 还持有一个 <code>ConcurrentHashMap&lt;Elevator.ElevatorType, RequestQueue&gt;</code> 类型的 <code>requestQueue</code>，它存储了楼座和电梯请求队列之间的映射关系，在本次作业中每个楼座只有一台电梯，所以可以说一个楼座共用一个请求队列，也可以说一部电梯拥有一个请求队列。</p>
<p>🤐 <strong><code>Strategy</code></strong>：</p>
<p>​		考虑到后续可能出现不同种类的电梯，它们运行的策略各不相同，于是创建了 <code>Strategy</code> 接口，让每部电梯持有一个其实现并调用 <code>getNext ()</code> 方法，这样就可以适应多种电梯的状况。在这里的策略我的设计是：电梯在 <code>StateWaiting</code> 状态判断是否需要运动，如果需要运动，则根据 ** 当前外部请求队列（等待被接的请求）和内部请求队列（等待送达的请求）** 来判断下一层该去往哪里，然后直接切换到 <code>StateMoving</code> 状态并更改楼层 &amp; 输出，在此过程中不会理睬外部队列增加的请求，即不会因为外部队列增加的请求而在运动途中更改目的地楼层。总体来说算是一种静态策略，但是效率尚可，同时避免了动态规划造成的线程不安全或者死锁之类的问题。</p>
<p>​		大致的电梯调度策略参考了 look 算法：优先判断电梯运行的方向前方是否还有 ** 同方向 ** 的目的地楼层（内部请求的目的地楼层和外部请求的起始楼层），如果有则去接 / 送，否则看是否有 ** 反方向 ** 需要接的请求，有则去接请求，没有就调转方向。注意去往目的地楼层后如果要接请求，不能把请求都接进来，而是只接 ** 同方向 ** 的请求。这里 <code>Strategy</code> 参考两个队列的请求数据计算去往楼层时要同时考虑电梯的方向和请求的方向，并且有很多临界条件，所以比较容易出 bug（比如在同一个楼层反复开关门，因为没有可以接到的请求而又没有调转方向）。</p>
<h4 id="🔒锁的选择和同步块设置"><a class="header-anchor" href="#🔒锁的选择和同步块设置">¶</a>🔒锁的选择和同步块设置</h4>
<p>​		本单元三次作业我都只使用了 <code>synchronized</code> 修饰同步块，没有使用如 <code>ReentrantLock</code> 或者 <code>Condition</code> 之类的多线程控制类。在同步块的设置上主要注意：<code>synchronized</code> 括起来的部分应当尽可能小以提高多线程运行的效率，同时又需要保证对共享对象的操作要被完全包含以保证线程安全，这是需要一些权衡的。在本次作业中大面积 <code>synchronized</code> 块主要出现在各种 <code>State</code> 接口的实现类中，因为电梯并没有写线程安全方法（虽然其中包含的 <code>RequestQueue</code> 是线程安全类），所以要在状态转换之间自己实现。在本次作业中我由于 <code>synchronized</code> 块的范围设置不当而出现了巨大的 bug，~~ 追悔莫及～～。</p>
<h3 id="⛔出现的-bug"><a class="header-anchor" href="#⛔出现的-bug">¶</a>⛔出现的 bug</h3>
<p>本次作业的 bug 体现在两方面：</p>
<p>1️⃣（上面提到的）<code>Strategy</code> 逻辑错误，可能导致在特殊情况下电梯被卡在同一层反复开关门。</p>
<p>** 解决方法 **：改进策略类，对边界条件和特殊数据充分考虑。</p>
<p>2️⃣同步块范围设置过大，导致电梯效率大幅度下降而超时。</p>
<p>​		在状态模式中，切换状态的语句如下：（由此可以推出电梯内有一个 <code>State</code> 接口，而接口的实现类中又持有一部电梯）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">elevator.setState (<span class="keyword">new</span> StateOpen (elevator));</span><br><span class="line">elevator.getStatus ().behave ();</span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
<p>​		而我一开始将这三行写在了 <code>synchronized</code> 块内，导致这部电梯切换状态并 <code>behave ()</code> 的时候还处在上一个状态的锁中，这样状态反复切换，锁一层层叠加，而每个状态共享的对象都相同（即电梯的外部等待队列），导致共享对象被加了若干层锁，访问和操作的效率极低。而弱测和中测的数据强度不够，导致没有超时的情况发生。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(outsideQueue) &#123;</span><br><span class="line">        ...</span><br><span class="line">        elevator.setState (<span class="keyword">new</span> StateOpen (elevator));</span><br><span class="line">		elevator.getStatus ().behave ();	<span class="comment">// 即使切换了状态，但状态 behave 的时候依然在这层锁内 </span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>** 解决方法 **：大面积检查 <code>synchronized</code> 块的范围，尽可能减小代码块规模。</p>
<h2 id="✍第六次作业"><a class="header-anchor" href="#✍第六次作业">¶</a>✍第六次作业</h2>
<h3 id="🏠程序架构-v2"><a class="header-anchor" href="#🏠程序架构-v2">¶</a>🏠程序架构</h3>
<p><strong>（第二次作业的时序图和第一次作业基本相同，故不再重复展示）</strong></p>
<p><img src="/2022/05/26/BUAA-OO-U2-Review/BUAA-OO-U2-Review%5CU2A2.png" alt></p>
<p>​		第六次作业相比第五次作业主要增加了横向电梯和请求，并且可以动态增加横向和纵向的电梯。（<code>P</code> 代表 <code>parallel</code>，<code>V</code> 代表 <code>vertical</code>，下同）</p>
<h4 id="💬重要类描述-调度器设计-v2"><a class="header-anchor" href="#💬重要类描述-调度器设计-v2">¶</a>💬重要类描述 + 调度器设计</h4>
<p>（一些类和上一次作业基本相同或改动较小，故不再赘述）</p>
<p>🤐 <strong><code>InputHandler &amp; RequestDispatcher</code></strong>：</p>
<p>​		本次作业中一个楼层或一个楼座可以有多部电梯，我给每部电梯都分配了一个队列，这样它可以根据自己队列的信息计算要去往的楼层，不必自由竞争（虽然听说自由竞争的策略效果还不错）。</p>
<p>​		每一部电梯都对于横向和纵向电梯，都维护了一个 <code>ConcurrentHashMap&lt;Integer,CopyOnWriteArrayList&lt;Integer&gt;&gt;</code> 和 <code>ConcurrentHashMap&lt;Integer, RequestQueue&gt;</code>，前者记录了 <code>floor /building ---&gt; SET &#123;id&#125;</code> 的映射，体现每一层或每一栋楼有哪些电梯在工作；后者记录了 <code>id ---&gt; outsideQueue</code> 的映射。这样 <code>InputHandler</code> 在添加电梯的时候对这两个数据结构进行添加操作，<code>RequestDispatcher</code> 分配请求的时候根据 <code>floor /building</code> 找到 <code>SET &#123;id&#125;</code>，再根据电梯此时的压力 <code>insideQueue.size () + outsideQueue.size ()</code> 排序，将请求分配给压力最小的电梯。</p>
<p>​		其实这种排序的权重分配不见得完全合理，因为内外请求对电梯运行时间的影响可能不同，可以改成 <code>a * insideQueue.size () + b * outsideQueue.size ()</code> 这种形式，多跑几个测试点看看哪个参数对 $(a,b)$ 可以让时间最小（x</p>
<p>🤐 <strong><code>LiftV &amp; LiftP</code></strong>：</p>
<p>​		横向和纵向电梯的基本架构是类似的，仍然使用状态模式，只是把状态类写在了电梯类内部以增加电梯类字段的可见性。</p>
<p>​		纵向电梯的策略仍然沿用上一次作业的 look 算法。整体改动很小，故不再赘述。</p>
<p>​		横向电梯的特殊之处在于可以循环运动，这次作业中我规定横向电梯只能按照一个方向循环移动，在构造方法内的实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random ();</span><br><span class="line"><span class="keyword">this</span>.direction = random.nextInt (<span class="number">2</span>) == <span class="number">1</span> ? UP : DOWN;	</span><br><span class="line"><span class="comment">// UP = &quot;A -&gt; B -&gt; C -&gt; ...&quot;, DOWN = &quot;A -&gt; E -&gt; D -&gt; ...&quot;</span></span><br></pre></td></tr></table></figure>
<p>​		由上可知电梯请求的分配中没有考虑横向电梯的方向，这种方法看似暴力，但是在强测的大量随机数据测试中表现还不错，得到了 96 + 分。</p>
<h2 id="✍第七次作业"><a class="header-anchor" href="#✍第七次作业">¶</a>✍第七次作业</h2>
<h3 id="🏠程序架构-v3"><a class="header-anchor" href="#🏠程序架构-v3">¶</a>🏠程序架构</h3>
<p><img src="/2022/05/26/BUAA-OO-U2-Review/BUAA-OO-U2-Review%5CU2A3.png" alt></p>
<p>&lt;img src=“BUAA-OO-U2-Review\U2A3_seq.png” alt=&quot;&quot;style=“zoom:80%;” /&gt;</p>
<p>​		第七次作业在第六次作业的基础上添加了需要换乘的请求和横向电梯的可达性（即不一定可以在每个楼座开门）。</p>
<h4 id="💬重要类描述-调度器设计-v3"><a class="header-anchor" href="#💬重要类描述-调度器设计-v3">¶</a>💬重要类描述 + 调度器设计</h4>
<p>🤐 <strong><code>MyPersonRequest</code></strong>：</p>
<p>​		可以说这是本次作业最重要的一个类，它包装了官方包的 <code>Request</code> 类，含有下述字段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PersonRequest request;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> vertical;		<span class="comment">//	是否是纵向请求（默认不需要换乘）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> hasFirstShifted;	<span class="comment">//	是否完成换乘第一阶段 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> hasSecondShifted;	<span class="comment">//	是否完成换乘第二阶段 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> shiftFloor;		<span class="comment">//	需要换乘的楼层 </span></span><br></pre></td></tr></table></figure>
<p>​		“包装” 的含义就是，一个 <code>MyPersonRequest</code> 对象在创建之初就存储了所有的信息：换乘阶段、换乘楼层和 <code>PersonRequest</code> 对象的相关信息。但是可以根据三个 <code>boolean</code> 选择将哪些信息暴露给外面，这样其他类不需要拆包，也便于修改请求的状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">getFromBuilding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (!vertical &amp; hasSecondShifted) ? request.getToBuilding () : request.getFromBuilding ();&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">getToBuilding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (!vertical &amp; hasFirstShifted) ? request.getToBuilding () : request.getFromBuilding ();&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFromFloor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (!vertical &amp; hasFirstShifted) ? shiftFloor : request.getFromFloor ();&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getToFloor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (vertical || hasSecondShifted) ? request.getToFloor () : shiftFloor;&#125;</span><br></pre></td></tr></table></figure>
<p>​		本次作业可以让请求进行多次换乘，但是考虑到电梯运行和开关门的时间损耗，我只实现了一次换乘。一些动态的规划算法可以实现多次换乘，但是由于需要多次开关门，可能会得不偿失。请求的换乘可以看作三个阶段：<code>UP / DOWN -&gt; CHANGE BUILDING -&gt; UP / DOWN</code>，其中的两个箭头就标志了两个阶段的结束，<code>UP / DOWN</code> 在这里并不是必须的，因为有可能出现只需要横向移动就可以完成或者只需要一次纵向移动的请求。</p>
<p>​		<code>shiftFloor</code> 的计算是请求分配过程中最重要的一步，单个请求在不同楼层换乘的时间差别不会太大，但是如果在强测的环境下，几十个请求同时到来，如何妥当地安排它们是很重要的事情。身边有些同学使用了图算法，计算如何换乘可以实现最短路，我认为这样有些复杂～～（其实是自己懒）~~，只是写了一个根据电梯相关信息计算代价的函数，然后排序找代价最小的楼层 <strong>（别忘了可达性）</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">weight</span><span class="params">(LiftP lift, PersonRequest req)</span> </span>&#123;	<span class="comment">// 注意这里的参数类型仍然是 PersonRequest</span></span><br><span class="line">    <span class="keyword">int</span> upper = Integer.max (req.getFromFloor (), req.getToFloor ());</span><br><span class="line">    <span class="keyword">int</span> lower = Integer.min (req.getFromFloor (), req.getToFloor ());</span><br><span class="line">    <span class="keyword">int</span> floor = lift.getFloor ();</span><br><span class="line">    <span class="keyword">int</span> speed = lift.getMoveDur ();</span><br><span class="line">    <span class="keyword">int</span> boundWeight = (upper &lt; floor || lower &gt; floor) ?</span><br><span class="line">            (upper &lt; floor) ? <span class="number">100</span> + <span class="number">10</span> * (floor - upper) :</span><br><span class="line">                    <span class="number">100</span> + <span class="number">10</span> * (lower - floor) : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> speedWeight = speed / <span class="number">25</span>;</span><br><span class="line">    <span class="keyword">int</span> insidePressureWeight = lift.getInsideNum () * <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">int</span> outsidePressureWeight = lift.getOutsideNum () * <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">return</span> (boundWeight + speedWeight +</span><br><span class="line">            insidePressureWeight + outsidePressureWeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		这里的所有数字都是后来捏出来觉得比较合适的。其实也很玄学，可能改了也不会出什么问题，而且也有一定的运气成分，后来调参调不下去感觉找不到最优的参数（当然找不到），就填了个感觉还凑合的提交了，没想到强测中表现还不错。</p>
<p>🤐 <strong><code>Counter</code></strong>：</p>
<p>​		一个很自然的想法是：需要换乘的请求在某个阶段完成之后，修改对应的状态再返回给调度器中的等待队列进行分发。但是 <code>RequestDispatcher</code> 线程结束的条件是等待队列 <code>inputQueue</code> 为空且其 <code>reachEnd</code> 标记被设置，而后者是 <code>InputHandler</code> 线程设置的，条件为 <code>request == null</code>。这样的结束条件显然不能满足换乘请求，因为有可能出现从文件中输入的请求被读完且 <code>inputQueue</code> 中的请求都被分配，但是正在运行的电梯里有需要换乘的请求，而此时输入和调度器线程都提前结束了，这就导致会出现请求不能彻底完成的情况。</p>
<p>​		为了解决这个问题，可以增加一个计数器模块，它在 <code>InputHandler</code> 读入新请求的时候自增，在电梯彻底完成一个请求的时候自减。这样 <code>InputHandler</code> 在计数器为 0 且所有请求已经被读入的情况下才可以停止。其实现很简单，只需要注意线程安全即可。</p>
<h2 id="✔发现-bug-的策略"><a class="header-anchor" href="#✔发现-bug-的策略">¶</a>✔发现 bug 的策略</h2>
<h3 id="💦自己的-bug"><a class="header-anchor" href="#💦自己的-bug">¶</a>💦自己的 bug</h3>
<p>​		其实也没有什么成体系的策略，主要是随机数据点测试和自己手写小规模的测试点来检验特定模块的正确性。另外多线程的特点是 bug 不一定能复现，所以一个测试点多跑几次比较好。后来室友写了一个可以把输出根据不同电梯来拆分的程序，这使得 debug 过程效率提高了很多：原来只能肉眼观察小规模数据点的输出，最多只能看看有无死循环和异常，有了辅助程序就可以细致检查每部电梯是否正常运行，非常方便。</p>
<h3 id="👁‍🗨互测的-bug"><a class="header-anchor" href="#👁‍🗨互测的-bug">¶</a>👁‍🗨互测的 bug</h3>
<p>​		不得不说这单元的互测我没有第一单元积极，主要是没有数据生成器，手写数据点也很繁琐。所以互测中我只是提交了一些小规模的边界数据测试点，比如第一秒输入一个请求，等一分钟再加一部电梯这种（有的同学的程序不会正常结束）。</p>
<h2 id="🏃‍♀️心得体会"><a class="header-anchor" href="#🏃‍♀️心得体会">¶</a>🏃‍♀️心得体会</h2>
<p>​		电梯月终于结束了，不过个人感觉这单元的压力并没有比第一单元多很多～～（除了有次差点通宵以外）~~。第一次接触多线程编程，入门就花了很长时间，还好第一次作业赶上假期，课程组延长了几天，否则我是一定写不完的。因为第一次作业建立了一个还算合理的架构和电梯调度的算法（后面就没有动过，LOL），所以后面两次作业就比较顺利，线程之间如何沟通、同步等等都比较熟练了。</p>
<p>​		本单元作业一个最大的体会就是：大道至简（x）。在开始着手调度和请求分配算法的编写前，我想了很多实现的方法，身边的朋友和研讨课的同学也提出过很复杂但是效率很高的算法，~~ 一方面是因为自己比较懒，~~ 另一方面是觉得在强测这种大规模随机数据的测试中也许不一定越高级越好，所以第三次作业中的请求换乘楼层计算我只是写了个计算代价的函数，虽然看起来很原始，但是强测中没有低于 92 分的点，大部分都是 98 分上下。我的一个室友写了个更简短的计算代价的函数（可能只有几行或者十几行），最后强测分数比我高。因此电梯调度这种大规模且不确定性比较强的场景中不存在最佳的算法，但是可能存在代码效率最高的算法（指几行核心的调度算法得到强测 99+🤗）。</p>
]]></content>
      <tags>
        <tag>BUAA OO</tag>
      </tags>
  </entry>
  <entry>
    <title>「复分析」Chapter1：微积分</title>
    <url>/2021/12/07/%E5%A4%8D%E5%88%86%E6%9E%90Chapter1/</url>
    <content><![CDATA[<h2 id="一、回顾"><a class="header-anchor" href="#一、回顾">¶</a>一、回顾</h2>
<h4 id="外微分形式（-R-3-）"><a class="header-anchor" href="#外微分形式（-R-3-）">¶</a>外微分形式（$R^3$）</h4>
<ul>
<li>
<p>$\mathrm {d} x$ 与 $\mathrm {d} y$ 外乘积记作 $\mathrm {d} x∧\mathrm {d} y$，且有关系 $\mathrm {d} x∧\mathrm {d} y=-\mathrm {d} y∧\mathrm {d} x$.</p>
<span id="more"></span>
</li>
<li>
<p>对外微分形式 $\omega$ 定义微分算子 $\mathrm {d}$，则有：</p>
</li>
</ul>
<h5 id="①-omega-f-rightarrow-mathrm-d-omega-frac-partial-f-partial-x-mathrm-d-x-frac-partial-f-partial-y-mathrm-d-y-frac-partial-f-partial-z-mathrm-d-z"><a class="header-anchor" href="#①-omega-f-rightarrow-mathrm-d-omega-frac-partial-f-partial-x-mathrm-d-x-frac-partial-f-partial-y-mathrm-d-y-frac-partial-f-partial-z-mathrm-d-z">¶</a>$①\omega=f \rightarrow \mathrm {d}\omega=\frac {\partial f}{\partial x}\mathrm {d} x+\frac {\partial f}{\partial y}\mathrm {d} y+\frac {\partial f}{\partial z}\mathrm {d} z$</h5>
<h5 id="begin-split-②-omega-sum-limits-cyc-A-mathrm-d-y-wedge-mathrm-d-z-Rightarrow-mathrm-d-omega-sum-limits-cyc-frac-partial-A-partial-x-mathrm-d-x-wedge-mathrm-d-y-wedge-mathrm-d-z-end-split"><a class="header-anchor" href="#begin-split-②-omega-sum-limits-cyc-A-mathrm-d-y-wedge-mathrm-d-z-Rightarrow-mathrm-d-omega-sum-limits-cyc-frac-partial-A-partial-x-mathrm-d-x-wedge-mathrm-d-y-wedge-mathrm-d-z-end-split">¶</a>$\begin {split}②&amp;\omega=\sum\limits_{cyc} A\mathrm {d} y\wedge \mathrm {d} z \&amp;\Rightarrow \mathrm {d}\omega=(\sum\limits_{cyc} \frac {\partial A}{\partial x})\mathrm {d} x\wedge \mathrm {d} y\wedge \mathrm {d} z\end {split}$</h5>
<h5 id="begin-split-③-omega-P-mathrm-d-x-Q-mathrm-d-y-R-mathrm-d-z-Rightarrow-mathrm-d-omega-sum-limits-cyc-frac-partial-R-partial-y-frac-partial-Q-partial-z-mathrm-d-y∧-mathrm-d-z-end-split"><a class="header-anchor" href="#begin-split-③-omega-P-mathrm-d-x-Q-mathrm-d-y-R-mathrm-d-z-Rightarrow-mathrm-d-omega-sum-limits-cyc-frac-partial-R-partial-y-frac-partial-Q-partial-z-mathrm-d-y∧-mathrm-d-z-end-split">¶</a>$\begin {split}③\ &amp;\omega =P\mathrm {d} x+Q\mathrm {d} y+R\mathrm {d} z\&amp;\Rightarrow \mathrm {d}\omega=\sum\limits_{cyc}(\frac {\partial R}{\partial y}-\frac {\partial Q}{\partial z})\mathrm {d} y∧\mathrm {d} z \end {split}$</h5>
<h5 id="④-omega-H-mathrm-d-x-wedge-mathrm-d-y-wedge-mathrm-d-z-Rightarrow-mathrm-d-omega-0"><a class="header-anchor" href="#④-omega-H-mathrm-d-x-wedge-mathrm-d-y-wedge-mathrm-d-z-Rightarrow-mathrm-d-omega-0">¶</a>$④\omega = H \mathrm {d} x\wedge\mathrm {d} y\wedge\mathrm {d} z\Rightarrow\mathrm {d}\omega=0$</h5>
<ul>
<li>
<p>$(Poincare\ Lemma)$​	$\omega$​是外微分形式且系数有二阶连续偏导等价于 $\mathrm {d}\mathrm {d}\omega=0$​.（即若 $p$​次外微分形式 $\omega$​有 $\mathrm {d}\omega=0$​则存在 $p-1$​次外微分形式 $\alpha$​使得 $\omega=\mathrm {d}\alpha$​）</p>
</li>
<li>
<p>统一 $Green、Gauss、Stokes$​公式：$$\begin {align}\int_{\partial\Sigma}\ \omega=\int_{\Sigma}\ \mathrm {d}\omega\end {align}$$.​</p>
</li>
</ul>
<h2 id="二、复微分"><a class="header-anchor" href="#二、复微分">¶</a>二、复微分</h2>
<ul>
<li>$f:\mathbb {C}\rightarrow\mathbb {C}$​，导数定义类似。若 $f (z)$​在定义域上每一点可微，则称 $f$​ 解析或全纯.</li>
<li>$(Cauchy-Riemann)$​	若 $f (z)=u (x,y)+iv (x,y)$​在 $z_{0}=x_{0}+iy_{0}$​处可微，则有</li>
</ul>
<p>$$<br>
\begin {align} f’(z_{0})&amp;=u’<em>{x}(x</em>{0},y_{0})+iv’<em>{x}(x</em>{0},y_{0})\&amp;=v’<em>{y}(x</em>{0},y_{0})-iu’<em>{x}(x</em>{0},y_{0})\end {align}<br>
$$</p>
<p>，由此立即推出：<br>
$$<br>
\begin {aligned}\frac {\partial f}{\partial x}+i\frac {\partial f}{\partial y}=0\ or\left{\begin {matrix} u’<em>{x}=v’</em>{y}\u’<em>{y}=-v’</em>{x}\end {matrix}\right.\end {aligned}<br>
$$</p>
<ul>
<li>
<p>$f (z)=u+iv$ 在 $D$ 内全纯 $\Leftrightarrow$$u,v$ 在 $D$ 内有一阶连续偏微商且满足 $Cauchy-Riemann$ 条件.</p>
</li>
<li>
<p>事实上，如果 $f (z)=u+iv$​在 $D$​内全纯，则 $f’(z)$​也在 $D$​内全纯，由此得到 $\Delta u=\Delta v=0$​.</p>
</li>
<li>
<p>引入记号：<br>
$$<br>
\left{<br>
\begin {align}<br>
\frac {\partial}{\partial z}=\frac {1}{2}(\frac {\partial}{\partial x}-i\frac {\partial}{\partial y})\<br>
\frac {\partial}{\partial \bar {z}}=\frac {1}{2}(\frac {\partial}{\partial x}+i\frac {\partial}{\partial y})<br>
\end {align}.<br>
\right.<br>
$$</p>
</li>
</ul>
<p>则 $f$ 全纯 $\Leftrightarrow$ $\begin {align}\frac {\partial f}{\partial \bar {z}}=0\end {align}$，同时 $\begin {align}\Delta =4\frac {\partial^2}{\partial z\partial \bar {z}}=4\frac {\partial^2}{\partial \bar {z}\partial z}\end {align}$.</p>
<ul>
<li>$\begin {align}\mathrm {d} f=\frac {\partial f}{\partial x}\mathrm {d} x+\frac {\partial f}{\partial y}\mathrm {d} y=\frac {\partial f}{\partial z}\mathrm {d} z+\frac {\partial f}{\partial \bar {z}}\mathrm {d}\bar {z}  \end {align}$， 记 $\begin {align}\partial f=\frac {\partial f}{\partial z}\mathrm {d} z,\bar {\partial} f=\frac {\partial f}{\partial \bar {z}}\mathrm {d}\bar {z} \end {align}$，则 $\mathrm {d}=\partial+\bar {\partial}$.</li>
<li>（共形性）设 $f$ 在 $D$ 全纯，$z_0\in D$ 且 $f’(z_0)\neq0$，曲线 $\gamma$ 满足 $\gamma (t)\ (0\leq t\leq1)$ 在 $D$ 内过 $z_0$ 且 $\gamma (0)=z_0$，$\gamma (t)$ 在 $z_0$ 处和实轴的夹角为 $arg\ \gamma’(t)$，$f$ 把 $\gamma$ 映射成曲线 $\sigma (t)=f (\gamma (t))$，则 $\sigma’(t)=\gamma’(t) f’(\gamma (t))$，因此 $arg\ f’(z_0)=arg\ \sigma’(0)-arg\ \gamma’(0)$<strong>（保角性）</strong>. 另外，有 $\begin {align}\frac {\vert {f (z)-f (z_0)}\vert}{\vert z-z_0\vert}=\frac {\vert\omega-\omega_0\vert}{\vert z-z_0\vert}\rightarrow\vert f’(z_0)\vert (z\rightarrow z_0,z\in \gamma) \end {align}$.</li>
</ul>
<h2 id="三、复积分"><a class="header-anchor" href="#三、复积分">¶</a>三、复积分</h2>
<ul>
<li>
<p>$\begin {align} f=u+iv\Rightarrow\int f (t)\mathrm {d} t=\int u (t)\mathrm {d} t+i\int v (t)\mathrm {d} t \end {align}.$</p>
</li>
<li>
<p>若 $\gamma$ 可求长，则：$\begin {align}\int_\gamma f (z)\mathrm {d} z=\int_\gamma (u+iv)(\mathrm {d} x+i\mathrm {d} y) \end {align}.$</p>
</li>
<li>
<p>复外微分形式：$\mathrm {d}\bar {z} \wedge \mathrm {d} z=2i\mathrm {d} x\wedge\mathrm {d} y=2i\mathrm {d} A.$</p>
</li>
<li>
<p>复形式的 Green 公式：若 $\omega=\omega_1\mathrm {d} z+\omega_2\mathrm {d} z$ 为 $\Omega$ 上的一次外微分算子，$\omega_1,\omega_2$ 为 $z,\bar {z}$ 的可微函数，则有 $\begin {align}\int_{\partial \Omega}\omega=\iint_\Omega \mathrm {d}\omega \end {align}.$</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>复分析</tag>
      </tags>
  </entry>
</search>
