<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Algebra Chapter 0 - 1.3 Categories</title>
    <url>/2021/12/10/Algebra-Chapter-0-1-3-Categories/</url>
    <content><![CDATA[<h4 id="definition-3.1.0">Definition 3.1.0</h4>
<p>​ A <span class="math inline">\(category\)</span> <span class="math inline">\(\mathsf{C}\)</span> consists of:</p>
<ul>
<li><p>a class <span class="math inline">\(\mathrm{Obj}(\mathsf{C})\)</span> of <span class="math inline">\(objects\)</span> of the category</p></li>
<li><p>for every two objects <span class="math inline">\(A,B\)</span> of <span class="math inline">\(\mathsf{C}\)</span> , a set <span class="math inline">\(\mathrm{Obj}_{\mathsf{C}}(A,B)\)</span> of <span class="math inline">\(morphisms\)</span> , with the properties listed below.</p></li>
</ul>
<p>​ Defining properties of morphisms:</p>
<ul>
<li>For every object <span class="math inline">\(A\)</span> of <span class="math inline">\(\mathsf{C}\)</span> , there exists (at least) one morphism <span class="math inline">\(1_A\in \mathrm{Hom}_\mathsf{C}(A,B)\)</span> , the ‘identity’ on <span class="math inline">\(A\)</span>.</li>
<li><span class="math inline">\(\mathrm{Hom}_\mathsf{C}(A,B)\times\mathrm{Hom}_\mathsf{C}(B,C)\)</span><span class="math inline">\(=\mathrm{Hom}_\mathsf{C}(A,C)\)</span>.</li>
<li>Composition Law: <span class="math inline">\((hg)f=h(gf)\)</span>.</li>
<li>For all <span class="math inline">\(f\in \mathrm{Hom}_\mathsf{C}(A,B)\)</span> , we have <span class="math inline">\(f1_A=1_Bf=f\)</span>.</li>
</ul>
<h4 id="definition-3.1.1">Definition 3.1.1</h4>
<p>​ <span class="math inline">\(\mathrm{End}_\mathsf{C}(A)=\mathrm{Hom}_\mathsf{C}(A,A)\)</span>.</p>
<h4 id="example-3.1">Example 3.1</h4>
<p>​ Consider category <span class="math inline">\(\mathsf{C}\)</span> , and let <span class="math inline">\(A\)</span> be an object of <span class="math inline">\(\mathsf{C}\)</span> . We define a category <span class="math inline">\(\mathsf{C}_A\)</span> whose objects are certain morphisms in <span class="math inline">\(\mathsf{C}\)</span> : <span class="math inline">\(\mathrm{Obj}(\mathsf{C}_A)=all\ morphisms\ from\ \)</span><span class="math inline">\(any\ object\ of\ \mathsf{C}\ to\ A\)</span> . Pictorially, an object in <span class="math inline">\(\mathsf{C}_{A}\)</span> is an arrow <span class="math inline">\(Z\stackrel{f}{\rightarrow}A\)</span> .</p>
<p>​ Suppose <span class="math inline">\(Z_1\stackrel{f_1}{\longrightarrow}A\)</span> and <span class="math inline">\(Z_2\stackrel{f_2}{\longrightarrow}A\)</span> , morphisms <span class="math inline">\(f_1\rightarrow f_2\)</span> are defined to be commutative diagrams shown below.</p>
<p><img src="/2021/12/10/Algebra-Chapter-0-1-3-Categories/Gr_1"></p>
<p>​ The composition of morphisms in <span class="math inline">\(\mathsf{C}\)</span> can be verified without difficulty. Categories constructed in this pattern is called <span class="math inline">\(slice \  category\)</span> , which is a special form of <span class="math inline">\(comma\ category\)</span> .</p>
<h4 id="example-3.2">Example 3.2</h4>
<p>​ An similar example of <strong>Example 3.1</strong> can be obtained by considering morphisms in a category <span class="math inline">\(\mathsf{C}\)</span> from a fixed object <span class="math inline">\(A\)</span> to all objects in <span class="math inline">\(\mathsf{C}\)</span>, with morphisms defined by suitable commutative diagrams. The category defined above is called <span class="math inline">\(coslice\ category\)</span>.</p>
<h4 id="example-3.3">Example 3.3</h4>
<p>​ An example of coslice category is shown by letting <span class="math inline">\(\mathsf{C=Set}\)</span> and <span class="math inline">\(A=\)</span> a fixed singleton <span class="math inline">\(\mathbb{S}\)</span>. We call this category <span class="math inline">\(\mathsf{Set^*}\)</span>.</p>
<p>​ An object in this category is a morphism <span class="math inline">\(f:\mathbb{S}\rightarrow S\)</span> in <span class="math inline">\(\mathsf{Set}\)</span> where <span class="math inline">\(S\)</span> is any set. The information of ab object in <span class="math inline">\(\mathsf{Set^*}\)</span> consists of the choice of a nonempty set <span class="math inline">\(S\)</span> and an element <span class="math inline">\(s\in S\)</span> which is the element <span class="math inline">\(f(*)\)</span>. Thus we may denote objects in this category as pairs <span class="math inline">\((S,s)\)</span>. A morphism between two such objects, <span class="math inline">\((S,s)\rightarrow(T,t)\)</span>, corresponds to a set function <span class="math inline">\(\sigma:S\rightarrow T\)</span> such that <span class="math inline">\(\sigma(s)=t\)</span>.</p>
<p>​ Objects of <span class="math inline">\(\mathsf{Set}^*\)</span> are called ‘pointed sets’ and many structures are pointed sets. For example, <strong>group homomorphisms</strong> sends one identity to another.</p>
]]></content>
      <tags>
        <tag>Algebra Chapter 0</tag>
      </tags>
  </entry>
  <entry>
    <title>Algebra Chapter 0 - 1.5 Univeral Properties</title>
    <url>/2022/01/17/Algebra-Chapter-0-1-5-Univeral-Properties/</url>
    <content><![CDATA[<h3 id="initial-and-final-objects">§5.1 - Initial and final objects</h3>
<h4 id="definition-5.1">Definition 5.1</h4>
<ul>
<li><p>Let <span class="math inline">\(\mathsf{C}\)</span> be a category. Then object <span class="math inline">\(I\)</span> of <span class="math inline">\(\mathsf{C}\)</span> is <strong><span class="math inline">\(initial\)</span></strong> if for every object <span class="math inline">\(A\)</span> of <span class="math inline">\(\mathsf{C}\)</span> there exists <strong>exactly one</strong> morphism <span class="math inline">\(I\rightarrow A\)</span> in <span class="math inline">\(\mathsf{C}\)</span>:</p>
<p><span class="math inline">\(\begin{align}\forall A \in \mathsf{Obj(C)}:\mathsf{Hom_C}(I,A)\end{align}\)</span> is a singleton.</p></li>
<li><p>An object <span class="math inline">\(F\)</span> of <span class="math inline">\(\mathsf{C}\)</span> is <span class="math inline">\(final\)</span> in <span class="math inline">\(\mathsf{C}\)</span> if for every object <span class="math inline">\(A\)</span> of <span class="math inline">\(C\)</span> there exists <strong>exactly one</strong> morphism <span class="math inline">\(A\rightarrow F\)</span> in <span class="math inline">\(\mathsf{C}\)</span>:</p>
<p><span class="math inline">\(\begin{align}\forall A\in \mathsf{Obj(C)}:\ \mathsf{Hom_C}(A,F) \end{align}\)</span> is a singleton.</p></li>
</ul>
<h4 id="proposition-5.4">Proposition 5.4</h4>
<ul>
<li><span class="math inline">\(I_1,I_2\ are\ both\ inital\ objects\Rightarrow I_1\cong I_2\)</span>.</li>
<li><span class="math inline">\(F_1,F_2\ are\ both\ final\ objects\Rightarrow F_1\cong F_2\)</span>.</li>
</ul>
<h3 id="universal-properties">§5.2 Universal Properties</h3>
<ul>
<li>We say that a construction satisfies a universal property when it may be viewed as a terminal object of a category. More often, the situation is complex and the ‘explanation’ of a universal property may follow the pattern, “object <span class="math inline">\(X\)</span> is universal with respect to the following property: for any <span class="math inline">\(Y\)</span> such that <span class="math inline">\(\dots\)</span> , there exists a unique morphism <span class="math inline">\(Y\rightarrow X\)</span> such that <span class="math inline">\(\dots\)</span> .”</li>
</ul>
<h3 id="quotients">§5.3 Quotients</h3>
<ul>
<li><p>“The quotient <span class="math inline">\(A/\sim\)</span> is universal with respect to the property of mapping <span class="math inline">\(A\)</span> to a set in such a way that equivalent elements have the same image.”</p></li>
<li><p>The assertion above is talking about functions <span class="math inline">\(A\stackrel{\phi}{\longrightarrow} Z\)</span> with <span class="math inline">\(Z\)</span> any set, satisfying the property: <span class="math inline">\(a&#39;\sim a&#39;&#39;\rightarrow \phi(a&#39;)=\phi(a&#39;&#39;)\)</span>. These morphisms are objects of a category; for convenience, let’s denote such an object by <span class="math inline">\((\phi,Z)\)</span>. The only reasonable way to define morphisms <span class="math inline">\((\phi_1,Z_1)\rightarrow(\phi_2,Z_2)\)</span> is as commutative diagrams</p>
<p><img src="/2022/01/17/Algebra-Chapter-0-1-5-Univeral-Properties/image-20220117215734905.png"></p></li>
</ul>
<h3 id="products">§5.4 Products</h3>
<ul>
<li><p>Let <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span> be sets, and consider the product <span class="math inline">\(A\times B\)</span>, with the two partial projections:</p>
<p><img src="/2022/01/17/Algebra-Chapter-0-1-5-Univeral-Properties/image-20220303222022906.png"></p></li>
</ul>
]]></content>
      <tags>
        <tag>Algebra Chapter 0</tag>
      </tags>
  </entry>
  <entry>
    <title>BUAA OO U1 Review</title>
    <url>/2022/03/22/BUAA-OO-U1-Review/</url>
    <content><![CDATA[<h1 id="buaa-oo-第一单元总结">BUAA OO 第一单元总结</h1>
<h2 id="第一次作业">- 第一次作业</h2>
<p>​ 第一次作业要求化简一个一元（变量只能为 <span class="math inline">\(x\)</span>）的表达式，其中可以出现空白符和连续的正负号，至少需要去掉所有括号。为了得到性能分，还需要进行合并同类项的操作。</p>
<h3 id="程序架构">程序架构</h3>
<p><img src="/2022/03/22/BUAA-OO-U1-Review/image-20220303222022906.png"></p>
<p><em>（一些类的 get 和 set 方法没有明确标出）</em></p>
<p>​ 第一次作业采用了递归下降的处理方法，各个类的作用如下：</p>
<ul>
<li><p><strong>Element</strong>：使用 <code>HashMap&lt;Integer,BigInteger&gt;</code> 存储各个元素的信息，其中 Key 表示次数，Value 表示系数。由于第一次作业不包含任何其他特殊函数，所以无论是因子、项还是表达式都可以用 Element 来存储，结构比较统一，方便运算和化简。</p>
<p>为方便叙述，给出因子、项和表达式的定义：</p>
<ul>
<li><b> 因子 </b>：（+/-）变量的幂 + 常数的幂 + 括号表达式的幂（其中幂次为 1 可以省略幂指数）</li>
<li><b> 项 </b>：因子的乘积</li>
<li><b> 表达式 </b>：项的加和</li>
</ul></li>
<li><p><strong>Token</strong>：存储表达式基本单元的类，如操作符、括号、操作数和变量。</p></li>
<li><p><strong>Lexer</strong>：对输入表达式进行词法分析的类，将字符串分割为若干 token 并存入 <code>ArrayList&lt;Token&gt;</code>，并且在读入过程中进行初步化简：</p>
<ul>
<li>将连续的一串加减号划归为一个加 / 减号。</li>
<li>对于操作数直接用字符串存储，在后续处理过程中可以直接使用转换为整数。</li>
</ul></li>
<li><p><strong>Parser</strong>：递归下降逐个解析 <code>ArrayList&lt;Tokens&gt;</code> 的元素。<code>glbPos</code> 表示 token 的位置，<code>isHigh () isMid () isLow ()</code> 方法判断此时的 token 是否代表运算符并判断优先级。递归下降的入口是 <code>parseExpr ()</code>，之后进入 <code>parseTerm ()</code> 和 <code>parseUnit ()</code>，再从 <code>parseUnit ()</code> 调用 <code>parseExpr ()</code> 实现递归下降。由于结构统一，因此每个 parse 方法的返回类型都是 Element。</p></li>
</ul>
<h3 id="基于度量的结构分析">基于度量的结构分析</h3>
<p><img src="/2022/03/22/BUAA-OO-U1-Review/image-20220322123607798.png"></p>
<p>​ 根据 CogC 指标排序，可以发现认知复杂度较高的方法为 <code>parseUnit ()</code> 和 <code>output ()</code>。</p>
<p>​ <code>parseUnit ()</code> 方法复杂度较高的原因是因子的定义比较多，需要判断类型和是否有乘方，导致其中出现很多判断分支；<code>output ()</code> 的原因类似，也是出现了很多分支来判断如何输出字符串。</p>
<h3 id="bug-分析">bug 分析</h3>
<p>​ 本次作业的 bug 出现在形式化定义上。一开始我把因子定义为变量的幂 + 常数 + 表达式的幂，可以注意到这里缺少了常数的幂，于是输入 <code>x*2**2</code> 获得的结果就为 <code>4*x**2</code>，因为程序把 <code>x*2</code>parse 成了一个整体，于是在强测中出现了 bug。在 <code>parseUnit ()</code> 方法中添加一个判断即可解决。</p>
<h2 id="第二次作业">- 第二次作业</h2>
<p>​ 第二次作业在第一次作业的基础上增加了三角函数（括号内只能是非负整数和 <span class="math inline">\(x\)</span> 的非负整数幂）、自定义函数和求和函数，依然要求去除不必要的括号并展开所有自定义函数和求和函数。本次作业的函数不能嵌套。</p>
<h3 id="程序架构-1">程序架构</h3>
<p><img src="/2022/03/22/BUAA-OO-U1-Review/image-20220322162937182.png"></p>
<p><em>（一些类的 get 和 set 方法没有明确标出）</em></p>
<p>​ 第二次作业仍然保持了递归下降的处理思路，因为找到了可以统一存储表达式各个部分的数据结构，感觉并没有重构的必要。<del>（其实是偷懒）</del></p>
<ul>
<li><p><strong>Poly</strong>：这里我将项定义为： <span class="math display">\[
\begin {align} a*({x^{b} }*\prod_{i=0}^{\infty}\ {sin^{s_i}(S_i)}*\prod_{j=0}^{\infty}\ {cos^{c_i}(C_j))} \end {align}
  \]</span> 而 Poly 则存储了最外层括号里面的内容，<span class="math inline">\(b\)</span> 对应 <code>exp</code>，<code>sinSet</code> 和 <code>cosSet</code> 分别对应两个累乘。<code>HashMap&lt;String,BigInteger&gt;</code> 中的 <code>String</code> 记录的是 <span class="math inline">\(S_i\)</span>，因为本次作业三角函数中只能是 <span class="math inline">\(x^p\ (p\ge0)\)</span> 或者 <span class="math inline">\(t\ (t\ge0,t\in \mathbb {Z})\)</span>，因此格式是完全确定且唯一的，可以用字符串存储。而且因子和项都可以用这种形式处理，这使得计算方面更加简便。</p></li>
<li><p><strong>Element</strong>：<code>HashMap&lt;Poly,BigInteger&gt;</code> 表示了 <code>Poly</code> 和系数 <span class="math inline">\(a\)</span> 的对应关系集合，即许多项的和。</p>
<p>其中包含了两个化简的方法，分别是特殊处理 <span class="math inline">\(sin (0)/cos (0)\)</span> 和处理三角函数平方和。</p></li>
<li><p><strong>PreProcessing</strong>：这个类用来处理自定义函数和求和函数，并且把第一次作业中出现的一些化简步骤整合了进来。下面简要说明如何处理两种函数。</p>
<ul>
<li><p><b> 自定义函数 </b>：</p>
<ul>
<li>读入自定义函数的定义，根据等号划分为左右两部分，分别为 <code>defL</code> 和 <code>defR</code>，使用正则匹配的捕获组来捕获 <code>defL</code> 的函数名以及变量（按顺序）。注意在此之前需要得到此函数变量的数量，然后使用特定的 Pattern 来匹配（我定义了一个 Pattern 数组，用来存放不同变量数量的 <code>defL</code> 正则表达式）。</li>
<li>当在输入中找到自定义函数（记为 <code>input</code>）的时候进行第二次正则匹配 &amp; 捕获（注意要找对函数名），按顺序获得需要代入的表达式，这样 <code>input</code> 和 <code>defL</code> 中参变量和实际表达式就以捕获组的序号进行了一一对应，方便处理如 <span class="math inline">\(f (y,x)=y-x\)</span> 等参变量不按顺序出现的自定义函数。</li>
<li>读取 <code>defR</code>，将参变量替换为对应需要代入的表达式即可（记得在每个代入的表达式外套一层括号来表示这是一个整体，防止替换回去之后产生错误），这里需要注意的一点是如果先进行了 <span class="math inline">\(y\)</span> 或者 <span class="math inline">\(z\)</span> 的替换而参变量中有 <span class="math inline">\(x\)</span>，那么在将 <span class="math inline">\(y\)</span> 替换为含 <span class="math inline">\(x\)</span> 的表达式之后可能会重复替换 <span class="math inline">\(x\)</span>（比如 <span class="math inline">\(f (y,x)=y-x\)</span>，<code>input</code> 为 <span class="math inline">\(f (x,x+1)\)</span>，那么替换过程就是 <span class="math inline">\(y-x\rightarrow x-x\rightarrow (x+1)-(x+1)\rightarrow 0\)</span>，这显然是不正确的）。这里我的解决方法是：在替换的时候都把 <span class="math inline">\(x\)</span> 替换为不相关的字符 <span class="math inline">\(w\)</span>，最后再统一 <code>replaceAll ("w","x")</code> 即可。</li>
</ul>
<p>在处理自定义函数的时候，助教一再强调不要暴力字符串替换，而是 <b> 先对表达式进行建模，再代入原式 </b> ，奈何我没有想到很好的建模方法，于是只是使用了暴力替换。不过如果用表达式树处理的话建模会方便很多，可以先对各个表达式建一棵树，代入的时候替换掉上面的节点再插入原来的表达式树即可。</p></li>
<li><p><b> 求和函数 </b>：也是使用了字符串替换的方法，通过循环 + StringBuilder 构建需要替换的字符串。这里有三个需要注意的点：</p>
<ul>
<li><span class="math inline">\(sin\)</span> 中也包含字母 i，替换的时候要小心。可以先把三角函数名提前换为 s&amp;c 来解决。</li>
<li>如果求和上限小于下限，则本项应为 0。</li>
<li>求和上下限最好定义为 <code>BigInteger</code> 类型防止溢出。</li>
</ul></li>
</ul></li>
<li><p><strong>Lexer&amp;Parser&amp;Token</strong>：和第一次作业基本相同。</p></li>
</ul>
<h3 id="基于度量的结构分析-1">基于度量的结构分析</h3>
<p><img src="/2022/03/22/BUAA-OO-U1-Review/image-20220322174205046.png"></p>
<p>​ 根据 CogC 指标排序发现，认知复杂度较高的方法前两位仍然是 <code>parseUnit ()</code> 和 <code>output ()</code>，这是更复杂的因子定义和更复杂的输出逻辑造成的。此外一些化简方法的复杂度也较高。</p>
<h3 id="bug-分析-1">bug 分析</h3>
<p>​ 本次作业在强测和互测中都没有出现 bug，不过强测中一些点的性能分不高，这是因为我用原始的字符串来存储三角函数的内容，处理 <span class="math inline">\(sin (0)/cos (0)\)</span> 的化简时只考虑到字符串内容为 “0” 而忽视了 <span class="math inline">\(sin (-0)\)</span>、<span class="math inline">\(cos (+0)\)</span> 等，造成没有化简完全的情况。</p>
<h2 id="第三次作业">- 第三次作业</h2>
<p>​ 第三次作业在第二次作业的基础上允许了自定义函数的嵌套（求和函数内不允许出现自定义函数），同时三角函数内可以为表达式。</p>
<h3 id="程序架构-2">程序架构</h3>
<p><img src="/2022/03/22/BUAA-OO-U1-Review/image-20220322175955155.png"></p>
<p><em>（一些类的 get 和 set 方法没有明确标出）</em></p>
<p>​ 第三次作业在第二次作业的基础上只需要改动很少就可以，所以保持了原来的架构。其中最核心的改动是将 Poly 中存储三角函数的结构改为 <code>HashMap&lt;Element,BigInteger&gt;</code>，并～（差不多）~ 重写了 Poly 和 Element 的 <code>equals ()</code> 方法。</p>
<p>​ 但是如果想要化简结果，则需要耗费很多时间来完善代码和测试。我花了大概两天时间才基本完成大概化简方法，其中有无数次测试 <span class="math inline">\(\rightarrow\)</span> 发现 bug<span class="math inline">\(\rightarrow\)</span> 修改代码 <span class="math inline">\(\rightarrow\)</span> 测试的循环😭。最核心的是三角函数平方和的化简，大致的逻辑为：</p>
<ul>
<li>遍历 Element 的 <code>HashMap</code>，看是否同时有两个不同的项，其中一个 <span class="math inline">\(sin\)</span> 的次数大于等于 2，另一个 <span class="math inline">\(cos\)</span> 的次数大于等于 2，并且其中包含的内容相同（<b> 这里需要重写 <code>equals ()</code> 方法 </b>，我自己另外写了一个 <code>equal ()</code> 来替代，这是不明智的做法）。其中内容相同的第一要素是三角函数中 Element 的 <code>HashMap</code> 的大小相同，所以需要在每次运算之后进行一次同类项合并。</li>
<li>判断这两项在分别将第一步找出来的 <span class="math inline">\(sin\)</span> 和 <span class="math inline">\(cos\)</span> 次数减去 2 之后，剩下的部分是否相同，如果相同，则把 <span class="math inline">\(cos\)</span> 那项的系数减过去，而它自己丢掉一个 <span class="math inline">\(cos^2\)</span>。比如 <span class="math display">\[x*sin^3 (x+1)+2*cos^2 (x+1)*x*sin (x+1)\]</span> 化简为 <span class="math display">\[-x*sin^3 (x+1)+x*sin (x+1)\]</span> ，本质上就是作了 <span class="math inline">\(cos^2 P=1-sin^2 P\)</span> 的替换，虽然不是每个表达式都能完全化简，不过在相当一部分测试样例中都是奏效的。</li>
</ul>
<p>​ <b> 这里一个重要的点是深拷贝 / 浅拷贝的区别，比如第二步去掉 <span class="math inline">\(cos^2\)</span> 只需浅拷贝，直接修改 <code>this</code> 的 Poly 就可以，但是第一步中判断” 包含的内容相同 “时，不能真的分别去掉 <span class="math inline">\(sin^2\)</span> 和 <span class="math inline">\(cos^2\)</span>，而是需要复制一份独立的副本（不是引用同一个地址的数据，而是两块独立的内存空间，其中的内容相同），为此可以直接写一个 <code>copy ()</code> 方法来复制，也可以用序列化方法来实现深拷贝（具体实现原理可以上网搜索）。</b></p>
<p>附序列化实现深拷贝的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialCloneable</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>,<span class="title">Serializable</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">try</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="comment">//save the object to a byte array  </span></span><br><span class="line">            ByteArrayOutputStream bout = <span class="keyword">new</span> ByteArrayOutputStream ();  </span><br><span class="line">            ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream (bout);  </span><br><span class="line">            out.writeObject (<span class="keyword">this</span>);  </span><br><span class="line">            out.close ();  </span><br><span class="line"></span><br><span class="line">            <span class="comment">//read a clone of the object from the byte array  </span></span><br><span class="line">            ByteArrayInputStream bin = <span class="keyword">new</span> ByteArrayInputStream (bout.toByteArray ());  </span><br><span class="line">            ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream (bin);  </span><br><span class="line">            Object result = in.readObject ();  </span><br><span class="line">            in.close ();  </span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception e)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;    </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基于度量的结构分析-2">基于度量的结构分析</h3>
<p><img src="/2022/03/22/BUAA-OO-U1-Review/image-20220322182027486.png"></p>
<p>​ 根据分析数据可知，认知复杂度较高的方法主要是化简和输出。本次作业中 <code>parseUnit ()</code> 方法被拆分了，所以复杂度有所降低。</p>
<h3 id="bug-分析-2">bug 分析</h3>
<p>​ 本次作业出现了一些 bug，分析如下：</p>
<ul>
<li>由于自定义函数允许嵌套，使用正则表达式捕获组处理输入的表达式会出现错误：
<ul>
<li><b> 正则表达式不能进行括号的匹配 </b>，可能会在嵌套的函数中间进行截断，导致程序结果错误甚至报错。</li>
<li><b> 解决方法 </b>：自行实现自定义函数内部表达式的括号匹配，等价于自己重新写了一个” 更加智能 “的捕获组。</li>
</ul></li>
<li>三角函数输出格式错误：
<ul>
<li><b><code>output ()</code> 调用的 <code>needBracket ()</code> 方法逻辑有误 </b> ，一些情况下会少输出一对三角函数内的括号，比如应该输出 <span class="math inline">\(sin ((5*cos (x)))\)</span> 而只输出了 <span class="math inline">\(sin (5*cos (x))\)</span>。</li>
<li><b> 解决方法 </b>：调整 <code>needBracket ()</code> 内部的逻辑。</li>
</ul></li>
</ul>
<h2 id="hack-策略">- hack 策略</h2>
<p>​ 下载其他同学的代码更多是为了学习架构（毕竟也没有自动评测机 + 没有发现细枝末节的 bug），因此在第一单元的互测中我并没有查看很多同学的代码，更多还是提交边缘数据和测试中出现 bug 的数据。</p>
<h2 id="架构设计评价">- 架构设计评价</h2>
<p>​ 三次作业的架构给我最大的印象就是：<b> 居然没有使用接口和继承 </b>。</p>
<p>​ 其实第一单元作业并没有给我一种逐渐摸索架构的感觉，因为从第一次作业使用 <code>HashMap</code> 处理各种元素之后，第二次作业我的第一个思路就是：如何填充 <code>HashMap</code> 来继续保持结构的统一性。于是后来增加的 Poly 类就不能算是架构很大的调整，无非是细枝末节的完善以迎合新的需求，最后的第三次作业也可以说完全继承了第一次作业的架构。</p>
<p>​ 可能是因为找到了一个统一的数据结构来存储因子、项和表达式，我没有再对项目进行细化处理。所有的计算都包含在 Element 和 Poly 类中；所有的表达式整体化简都在 PreProcessing 类中；所有的词法语法分析都包含在 Lexer 和 Parser 类中，相互之间的依赖关系比较浅，一个类处理完后交给另一个类。总体来说类之间的耦合程度很低，每个类基本上在各司其职，内聚程度比较高。</p>
<p>​ 但是我认为这种架构的可扩展性不够，并且没有很好遵守” 对新增开放、对修改关闭 “的编程原则。可以发现从第一次到第三次作业的过程中，Element 类在不断膨胀，虽然后两次中添加了 Poly 来” 分担 “处理表达式的职能，但是仍然不是一个很好的解决方案。如果后续还有第四次甚至第五次迭代，这个架构有两种结果：要么膨胀到复杂度极高的状态，要么只能推倒重构。如果想要提高可扩展性，可以将 Element 和 Parser 拆开，增加其他的表达式元素类并使用接口。</p>
<h2 id="心得体会">- 心得体会</h2>
<p>​ 面向对象第一单元到这里就告一段落了，在本学期开始之前，我对 OO 的设想是：无非只是学一门新语言而已，但是这一单元带给我的绝不止熟悉 Java 的语法那么简单。面向对象不只是一种编程思想，还是一种理解世界的抽象化思维，它更加贴近人们平常认识事物的方式，并且便于迭代开发（这一单元使用面向过程恐怕最多可以通过第一次作业）。无论是对未来的程序设计还是对认识世界的思维方式，面向对象思想都大有可用之处。</p>
]]></content>
      <tags>
        <tag>BUAA OO</tag>
      </tags>
  </entry>
  <entry>
    <title>BUAA OO U2 Review</title>
    <url>/2022/05/26/BUAA-OO-U2-Review/</url>
    <content><![CDATA[<p>#🛰BUAA OO 第二单元总结</p>
<h2 id="第五次作业">✍第五次作业</h2>
<h3 id="程序架构">🏠程序架构</h3>
<p><strong>（UML 类图中省略了一些不重要的 <code>getter&amp;setter</code> 方法和构造方法，下同）</strong></p>
<p><img src="/2022/05/26/BUAA-OO-U2-Review/U2A1.png"></p>
<h4 id="重要类描述-调度器设计">💬重要类描述 + 调度器设计</h4>
<p>🤐 <strong><code>RequestQueue</code></strong>：</p>
<p>​ 第一次作业对于 <code>Request</code> 的处理比较常规，就是和大部分同学一样写了线程安全类 <code>RequestQueue</code> 以保证重要结构被多线程同时访问时的数据安全。内部包含 <code>ConcurrentLinkedQueue&lt;PersonRequest&gt;</code> 作为请求载体，直接包装其自带的线程安全方法（<code>poll ()</code>、<code>peek ()</code> 和 <code>remove ()</code> 等等）即可。线程安全的数据结构除此之外还有 <code>ArrayBlockingQueue</code>、<code>ConcurrentHashMap/ConcurrentHashSet</code>、<code>Vector</code> 和 <code>CopyOnWriteArrayList</code> 等等，可以满足绝大部分的需要了。</p>
<p>🤐 <strong><code>Elevator</code></strong>：</p>
<p>​ 电梯的功能的实现我采用了状态模式，因为电梯在这里只有四种状态：** 开门、关门、移动、等待 **，并且其之间的转换都遵循严格的条件，于是电梯可以拥有一个 <code>State</code> 接口字段，在状态转换的时候用 <code>setter</code> 方法切换一个 <code>new StateXXX ()</code>，并调用其中的方法 <code>behave ()</code> 的实现即可。一开始准备使用工厂模式来新建电梯的，但是由于本次作业对新增电梯没有考察且运行的电梯只有一种，所以为了简便就暂时搁置。</p>
<p>🤐 <strong><code>InputHandler &amp; RequestDispatcher</code></strong>：</p>
<p>​ 这两个类共同持有一个 <code>RequestQueue</code> 对象 <code>waitQueue</code>，表示等待队列。<code>InputHandler</code> 从输入中获取的 <code>Request</code> 被首先放入此队列等待，然后 <code>RequestDispatcher</code> 根据请求的楼座分配给对应的电梯即可。在此过程中要注意共享对象的线程安全问题并使用 <code>notifyAll ()</code> 及时唤醒等待在此对象上的线程。<code>RequestDispatcher</code> 还持有一个 <code>ConcurrentHashMap&lt;Elevator.ElevatorType, RequestQueue&gt;</code> 类型的 <code>requestQueue</code>，它存储了楼座和电梯请求队列之间的映射关系，在本次作业中每个楼座只有一台电梯，所以可以说一个楼座共用一个请求队列，也可以说一部电梯拥有一个请求队列。</p>
<p>🤐 <strong><code>Strategy</code></strong>：</p>
<p>​ 考虑到后续可能出现不同种类的电梯，它们运行的策略各不相同，于是创建了 <code>Strategy</code> 接口，让每部电梯持有一个其实现并调用 <code>getNext ()</code> 方法，这样就可以适应多种电梯的状况。在这里的策略我的设计是：电梯在 <code>StateWaiting</code> 状态判断是否需要运动，如果需要运动，则根据 ** 当前外部请求队列（等待被接的请求）和内部请求队列（等待送达的请求）** 来判断下一层该去往哪里，然后直接切换到 <code>StateMoving</code> 状态并更改楼层 &amp; 输出，在此过程中不会理睬外部队列增加的请求，即不会因为外部队列增加的请求而在运动途中更改目的地楼层。总体来说算是一种静态策略，但是效率尚可，同时避免了动态规划造成的线程不安全或者死锁之类的问题。</p>
<p>​ 大致的电梯调度策略参考了 look 算法：优先判断电梯运行的方向前方是否还有 ** 同方向 ** 的目的地楼层（内部请求的目的地楼层和外部请求的起始楼层），如果有则去接 / 送，否则看是否有 ** 反方向 ** 需要接的请求，有则去接请求，没有就调转方向。注意去往目的地楼层后如果要接请求，不能把请求都接进来，而是只接 ** 同方向 ** 的请求。这里 <code>Strategy</code> 参考两个队列的请求数据计算去往楼层时要同时考虑电梯的方向和请求的方向，并且有很多临界条件，所以比较容易出 bug（比如在同一个楼层反复开关门，因为没有可以接到的请求而又没有调转方向）。</p>
<h4 id="锁的选择和同步块设置">🔒锁的选择和同步块设置</h4>
<p>​ 本单元三次作业我都只使用了 <code>synchronized</code> 修饰同步块，没有使用如 <code>ReentrantLock</code> 或者 <code>Condition</code> 之类的多线程控制类。在同步块的设置上主要注意：<code>synchronized</code> 括起来的部分应当尽可能小以提高多线程运行的效率，同时又需要保证对共享对象的操作要被完全包含以保证线程安全，这是需要一些权衡的。在本次作业中大面积 <code>synchronized</code> 块主要出现在各种 <code>State</code> 接口的实现类中，因为电梯并没有写线程安全方法（虽然其中包含的 <code>RequestQueue</code> 是线程安全类），所以要在状态转换之间自己实现。在本次作业中我由于 <code>synchronized</code> 块的范围设置不当而出现了巨大的 bug，~~ 追悔莫及～～。</p>
<h3 id="出现的-bug">⛔出现的 bug</h3>
<p>本次作业的 bug 体现在两方面：</p>
<p>1️⃣（上面提到的）<code>Strategy</code> 逻辑错误，可能导致在特殊情况下电梯被卡在同一层反复开关门。</p>
<p>** 解决方法 **：改进策略类，对边界条件和特殊数据充分考虑。</p>
<p>2️⃣同步块范围设置过大，导致电梯效率大幅度下降而超时。</p>
<p>​ 在状态模式中，切换状态的语句如下：（由此可以推出电梯内有一个 <code>State</code> 接口，而接口的实现类中又持有一部电梯）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">elevator.setState (<span class="keyword">new</span> StateOpen (elevator));</span><br><span class="line">elevator.getStatus ().behave ();</span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
<p>​ 而我一开始将这三行写在了 <code>synchronized</code> 块内，导致这部电梯切换状态并 <code>behave ()</code> 的时候还处在上一个状态的锁中，这样状态反复切换，锁一层层叠加，而每个状态共享的对象都相同（即电梯的外部等待队列），导致共享对象被加了若干层锁，访问和操作的效率极低。而弱测和中测的数据强度不够，导致没有超时的情况发生。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(outsideQueue) &#123;</span><br><span class="line">        ...</span><br><span class="line">        elevator.setState (<span class="keyword">new</span> StateOpen (elevator));</span><br><span class="line">		elevator.getStatus ().behave ();	<span class="comment">// 即使切换了状态，但状态 behave 的时候依然在这层锁内 </span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>** 解决方法 **：大面积检查 <code>synchronized</code> 块的范围，尽可能减小代码块规模。</p>
<h2 id="第六次作业">✍第六次作业</h2>
<h3 id="程序架构-1">🏠程序架构</h3>
<p><strong>（第二次作业的时序图和第一次作业基本相同，故不再重复展示）</strong></p>
<p><img src="/2022/05/26/BUAA-OO-U2-Review/U2A2.png"></p>
<p>​ 第六次作业相比第五次作业主要增加了横向电梯和请求，并且可以动态增加横向和纵向的电梯。（<code>P</code> 代表 <code>parallel</code>，<code>V</code> 代表 <code>vertical</code>，下同）</p>
<h4 id="重要类描述-调度器设计-1">💬重要类描述 + 调度器设计</h4>
<p>（一些类和上一次作业基本相同或改动较小，故不再赘述）</p>
<p>🤐 <strong><code>InputHandler &amp; RequestDispatcher</code></strong>：</p>
<p>​ 本次作业中一个楼层或一个楼座可以有多部电梯，我给每部电梯都分配了一个队列，这样它可以根据自己队列的信息计算要去往的楼层，不必自由竞争（虽然听说自由竞争的策略效果还不错）。</p>
<p>​ 每一部电梯都对于横向和纵向电梯，都维护了一个 <code>ConcurrentHashMap&lt;Integer,CopyOnWriteArrayList&lt;Integer&gt;&gt;</code> 和 <code>ConcurrentHashMap&lt;Integer, RequestQueue&gt;</code>，前者记录了 <code>floor /building ---&gt; SET &#123;id&#125;</code> 的映射，体现每一层或每一栋楼有哪些电梯在工作；后者记录了 <code>id ---&gt; outsideQueue</code> 的映射。这样 <code>InputHandler</code> 在添加电梯的时候对这两个数据结构进行添加操作，<code>RequestDispatcher</code> 分配请求的时候根据 <code>floor /building</code> 找到 <code>SET &#123;id&#125;</code>，再根据电梯此时的压力 <code>insideQueue.size () + outsideQueue.size ()</code> 排序，将请求分配给压力最小的电梯。</p>
<p>​ 其实这种排序的权重分配不见得完全合理，因为内外请求对电梯运行时间的影响可能不同，可以改成 <code>a * insideQueue.size () + b * outsideQueue.size ()</code> 这种形式，多跑几个测试点看看哪个参数对 <span class="math inline">\((a,b)\)</span> 可以让时间最小（x</p>
<p>🤐 <strong><code>LiftV &amp; LiftP</code></strong>：</p>
<p>​ 横向和纵向电梯的基本架构是类似的，仍然使用状态模式，只是把状态类写在了电梯类内部以增加电梯类字段的可见性。</p>
<p>​ 纵向电梯的策略仍然沿用上一次作业的 look 算法。整体改动很小，故不再赘述。</p>
<p>​ 横向电梯的特殊之处在于可以循环运动，这次作业中我规定横向电梯只能按照一个方向循环移动，在构造方法内的实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random ();</span><br><span class="line"><span class="keyword">this</span>.direction = random.nextInt (<span class="number">2</span>) == <span class="number">1</span> ? UP : DOWN;	</span><br><span class="line"><span class="comment">// UP = &quot;A -&gt; B -&gt; C -&gt; ...&quot;, DOWN = &quot;A -&gt; E -&gt; D -&gt; ...&quot;</span></span><br></pre></td></tr></table></figure>
<p>​ 由上可知电梯请求的分配中没有考虑横向电梯的方向，这种方法看似暴力，但是在强测的大量随机数据测试中表现还不错，得到了 96 + 分。</p>
<h2 id="第七次作业">✍第七次作业</h2>
<h3 id="程序架构-2">🏠程序架构</h3>
<p><img src="/2022/05/26/BUAA-OO-U2-Review/U2A3.png"></p>
<p><img src="/2022/05/26/BUAA-OO-U2-Review/U2A3_seq.png" alt style="zoom:80%;"></p>
<p>​ 第七次作业在第六次作业的基础上添加了需要换乘的请求和横向电梯的可达性（即不一定可以在每个楼座开门）。</p>
<h4 id="重要类描述-调度器设计-2">💬重要类描述 + 调度器设计</h4>
<p>🤐 <strong><code>MyPersonRequest</code></strong>：</p>
<p>​ 可以说这是本次作业最重要的一个类，它包装了官方包的 <code>Request</code> 类，含有下述字段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PersonRequest request;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> vertical;		<span class="comment">//	是否是纵向请求（默认不需要换乘）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> hasFirstShifted;	<span class="comment">//	是否完成换乘第一阶段 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> hasSecondShifted;	<span class="comment">//	是否完成换乘第二阶段 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> shiftFloor;		<span class="comment">//	需要换乘的楼层 </span></span><br></pre></td></tr></table></figure>
<p>​ “包装” 的含义就是，一个 <code>MyPersonRequest</code> 对象在创建之初就存储了所有的信息：换乘阶段、换乘楼层和 <code>PersonRequest</code> 对象的相关信息。但是可以根据三个 <code>boolean</code> 选择将哪些信息暴露给外面，这样其他类不需要拆包，也便于修改请求的状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">getFromBuilding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (!vertical &amp; hasSecondShifted) ? request.getToBuilding () : request.getFromBuilding ();&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">getToBuilding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (!vertical &amp; hasFirstShifted) ? request.getToBuilding () : request.getFromBuilding ();&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFromFloor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (!vertical &amp; hasFirstShifted) ? shiftFloor : request.getFromFloor ();&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getToFloor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (vertical || hasSecondShifted) ? request.getToFloor () : shiftFloor;&#125;</span><br></pre></td></tr></table></figure>
<p>​ 本次作业可以让请求进行多次换乘，但是考虑到电梯运行和开关门的时间损耗，我只实现了一次换乘。一些动态的规划算法可以实现多次换乘，但是由于需要多次开关门，可能会得不偿失。请求的换乘可以看作三个阶段：<code>UP / DOWN -&gt; CHANGE BUILDING -&gt; UP / DOWN</code>，其中的两个箭头就标志了两个阶段的结束，<code>UP / DOWN</code> 在这里并不是必须的，因为有可能出现只需要横向移动就可以完成或者只需要一次纵向移动的请求。</p>
<p>​ <code>shiftFloor</code> 的计算是请求分配过程中最重要的一步，单个请求在不同楼层换乘的时间差别不会太大，但是如果在强测的环境下，几十个请求同时到来，如何妥当地安排它们是很重要的事情。身边有些同学使用了图算法，计算如何换乘可以实现最短路，我认为这样有些复杂～～（其实是自己懒）~~，只是写了一个根据电梯相关信息计算代价的函数，然后排序找代价最小的楼层 <strong>（别忘了可达性）</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">weight</span><span class="params">(LiftP lift, PersonRequest req)</span> </span>&#123;	<span class="comment">// 注意这里的参数类型仍然是 PersonRequest</span></span><br><span class="line">    <span class="keyword">int</span> upper = Integer.max (req.getFromFloor (), req.getToFloor ());</span><br><span class="line">    <span class="keyword">int</span> lower = Integer.min (req.getFromFloor (), req.getToFloor ());</span><br><span class="line">    <span class="keyword">int</span> floor = lift.getFloor ();</span><br><span class="line">    <span class="keyword">int</span> speed = lift.getMoveDur ();</span><br><span class="line">    <span class="keyword">int</span> boundWeight = (upper &lt; floor || lower &gt; floor) ?</span><br><span class="line">            (upper &lt; floor) ? <span class="number">100</span> + <span class="number">10</span> * (floor - upper) :</span><br><span class="line">                    <span class="number">100</span> + <span class="number">10</span> * (lower - floor) : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> speedWeight = speed / <span class="number">25</span>;</span><br><span class="line">    <span class="keyword">int</span> insidePressureWeight = lift.getInsideNum () * <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">int</span> outsidePressureWeight = lift.getOutsideNum () * <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">return</span> (boundWeight + speedWeight +</span><br><span class="line">            insidePressureWeight + outsidePressureWeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 这里的所有数字都是后来捏出来觉得比较合适的。其实也很玄学，可能改了也不会出什么问题，而且也有一定的运气成分，后来调参调不下去感觉找不到最优的参数（当然找不到），就填了个感觉还凑合的提交了，没想到强测中表现还不错。</p>
<p>🤐 <strong><code>Counter</code></strong>：</p>
<p>​ 一个很自然的想法是：需要换乘的请求在某个阶段完成之后，修改对应的状态再返回给调度器中的等待队列进行分发。但是 <code>RequestDispatcher</code> 线程结束的条件是等待队列 <code>inputQueue</code> 为空且其 <code>reachEnd</code> 标记被设置，而后者是 <code>InputHandler</code> 线程设置的，条件为 <code>request == null</code>。这样的结束条件显然不能满足换乘请求，因为有可能出现从文件中输入的请求被读完且 <code>inputQueue</code> 中的请求都被分配，但是正在运行的电梯里有需要换乘的请求，而此时输入和调度器线程都提前结束了，这就导致会出现请求不能彻底完成的情况。</p>
<p>​ 为了解决这个问题，可以增加一个计数器模块，它在 <code>InputHandler</code> 读入新请求的时候自增，在电梯彻底完成一个请求的时候自减。这样 <code>InputHandler</code> 在计数器为 0 且所有请求已经被读入的情况下才可以停止。其实现很简单，只需要注意线程安全即可。</p>
<h2 id="发现-bug-的策略">✔发现 bug 的策略</h2>
<h3 id="自己的-bug">💦自己的 bug</h3>
<p>​ 其实也没有什么成体系的策略，主要是随机数据点测试和自己手写小规模的测试点来检验特定模块的正确性。另外多线程的特点是 bug 不一定能复现，所以一个测试点多跑几次比较好。后来室友写了一个可以把输出根据不同电梯来拆分的程序，这使得 debug 过程效率提高了很多：原来只能肉眼观察小规模数据点的输出，最多只能看看有无死循环和异常，有了辅助程序就可以细致检查每部电梯是否正常运行，非常方便。</p>
<h3 id="互测的-bug">👁‍🗨互测的 bug</h3>
<p>​ 不得不说这单元的互测我没有第一单元积极，主要是没有数据生成器，手写数据点也很繁琐。所以互测中我只是提交了一些小规模的边界数据测试点，比如第一秒输入一个请求，等一分钟再加一部电梯这种（有的同学的程序不会正常结束）。</p>
<h2 id="心得体会">🏃‍♀️心得体会</h2>
<p>​ 电梯月终于结束了，不过个人感觉这单元的压力并没有比第一单元多很多～～（除了有次差点通宵以外）~~。第一次接触多线程编程，入门就花了很长时间，还好第一次作业赶上假期，课程组延长了几天，否则我是一定写不完的。因为第一次作业建立了一个还算合理的架构和电梯调度的算法（后面就没有动过，LOL），所以后面两次作业就比较顺利，线程之间如何沟通、同步等等都比较熟练了。</p>
<p>​ 本单元作业一个最大的体会就是：大道至简（x）。在开始着手调度和请求分配算法的编写前，我想了很多实现的方法，身边的朋友和研讨课的同学也提出过很复杂但是效率很高的算法，~~ 一方面是因为自己比较懒，~~ 另一方面是觉得在强测这种大规模随机数据的测试中也许不一定越高级越好，所以第三次作业中的请求换乘楼层计算我只是写了个计算代价的函数，虽然看起来很原始，但是强测中没有低于 92 分的点，大部分都是 98 分上下。我的一个室友写了个更简短的计算代价的函数（可能只有几行或者十几行），最后强测分数比我高。因此电梯调度这种大规模且不确定性比较强的场景中不存在最佳的算法，但是可能存在代码效率最高的算法（指几行核心的调度算法得到强测 99+🤗）。</p>
]]></content>
      <tags>
        <tag>BUAA OO</tag>
      </tags>
  </entry>
  <entry>
    <title>BUAA OO U3 Review</title>
    <url>/2022/10/21/BUAA-OO-U3-Review/</url>
    <content><![CDATA[<h1 id="buaa-oo-第三单元总结">BUAA OO 第三单元总结</h1>
<h2 id="概述">🖊概述</h2>
<p>​ 本单元作业的目的是完成一个社交关系的模拟程序。在此社交关系被抽象成三个对象：<code>Network, Group, Person</code>；<code>Person</code> 和 <code>Person/Group</code> 之间还可以发送各种 <code>Message</code>。我们需要根据 JML 来完成一些指令，以完成题目的要求，如查询组内的社交值之类的操作。本单元的完成需要用到一些图论的基础算法。</p>
<h2 id="架构设计">🗺架构设计</h2>
<p><img src="/2022/10/21/BUAA-OO-U3-Review/diagram.png"></p>
<p>（版面所限，只展示最终的类图部分内容）</p>
<p>​ 除了题目中必须实现的接口和继承的异常类，我只添加了三个主要的类，分别是：异常计数器 <code>ExceptionCounter</code>、并查集 <code>UnionCheck</code> 和边 <code>Edge</code>。其中异常计数器和并查集都使用了单例模式方便访问并保证了数据的一致性。</p>
<p>​ 对于 <code>Edge</code>，只是简单存储了关系的两个端点和社交值。大致的属性和方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> id1, <span class="keyword">int</span> id2, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id1 = id1;</span><br><span class="line">        <span class="keyword">this</span>.id2 = id2;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="算法设计">✔算法设计</h2>
<p>本文不会详细介绍各个算法的具体原理，仅讨论应用方面的内容。</p>
<h3 id="并查集">📱并查集</h3>
<p>​ <code>qci</code> 指令要求查询两个人之间的连通性，即无向图中两点的连通性，考虑用路径压缩的并查集实现（不用路径压缩也可以）。</p>
<p>​ <code>UnionCheck</code> 类就是单例模式的全局并查集实现类，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionCheck</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> UnionCheck UNION = <span class="keyword">new</span> UnionCheck ();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HashMap&lt;Integer, Integer&gt; DATA = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UnionCheck <span class="title">fetch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ArrayList&lt;Edge&gt; EDGES = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPerson</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        DATA.put (id, id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> id1, <span class="keyword">int</span> id2)</span> </span>&#123;</span><br><span class="line">        DATA.compute (find (id1),(k, v) -&gt; find (id2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DATA.get (i) == i) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//simplify</span></span><br><span class="line">            DATA.put (i, find (DATA.get (i)));</span><br><span class="line">            <span class="keyword">return</span> DATA.get (i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(Edge edge)</span> </span>&#123;</span><br><span class="line">        EDGES.add (edge);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Edge&gt; <span class="title">getSortedEdges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EDGES.sort (Comparator.comparingInt (Edge::getValue));</span><br><span class="line">        <span class="keyword">return</span> EDGES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 其中最后一个方法 <code>getSortedEdge ()</code> 是为了实现 <code>kruskal</code> 算法而使用的，目的是将现存的所有关系（也就是边）按照社交值（也就是边权）从小到大排序并返回。当然也可以用优先队列实现，这样就不用每次调用都排序一次，降低了时间复杂度。</p>
<h2 id="kruskal-算法">💻Kruskal 算法</h2>
<p>​ <code>qlc</code> 指令需要我们给出图中包含某个顶点的最小生成树的边权之和。根据本单元作业的数据规模，只需要考虑稀疏图的情况，于是选用复杂度相对较低的 <code>Kruskal</code> 算法。其中需要重新建立一个顶点所在连通分量的小规模并查集，每添加一条边之前都判断获得的边之间会不会生成环路。具体代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">queryLeastConnection</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> PersonIdNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!contains (id)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> PersonNotFoundExc (id);</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;Edge&gt; edges = UnionCheck.fetch ().getSortedEdges ();</span><br><span class="line">    ArrayList&lt;Edge&gt; originEdges = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; union = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//initialize union &amp; originEdges</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; edges.size (); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((UnionCheck.fetch ().find (edges.get (i).getId1 ()) == UnionCheck.fetch ().find (id))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!union.containsKey (edges.get (i).getId1 ())) &#123;</span><br><span class="line">                union.put (edges.get (i).getId1 (), edges.get (i).getId1 ());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!union.containsKey (edges.get (i).getId2 ())) &#123;</span><br><span class="line">                union.put (edges.get (i).getId2 (), edges.get (i).getId2 ());</span><br><span class="line">            &#125;</span><br><span class="line">            originEdges.add (edges.get (i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//kruskal</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> size = originEdges.size ();</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        Edge e = originEdges.get (i);</span><br><span class="line">        <span class="keyword">int</span> a = e.getId1 ();</span><br><span class="line">        <span class="keyword">int</span> b = e.getId2 ();</span><br><span class="line">        <span class="keyword">int</span> val = e.getValue ();</span><br><span class="line">        <span class="keyword">if</span> (find (a, union) != find (b, union)) &#123;</span><br><span class="line">            merge (a, b, union);</span><br><span class="line">            ret += val;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt;= union.size () - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dijkstra-算法">🧵Dijkstra 算法</h3>
<p>​ <code>sim</code> 指令要求我们给出两个人之间的最短路径，考虑使用复杂度较低且易于实现的 <code>Dijkstra</code> 算法。在维护排序的路径方面我使用了优先队列的方式以获得较好的性能。具体代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sendIndirectMessage</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> MessageIdNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!containsMessage (id) || containsMessage (id) &amp;&amp; getMessage (id).getType () == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MessageNotFoundExc (id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> id1 = getMessage (id).getPerson1 ().getId ();</span><br><span class="line">    <span class="keyword">int</span> id2 = getMessage (id).getPerson2 ().getId ();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isCircle (id1, id2)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PersonIdNotFoundException ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    Person p1 = getPerson (id1);</span><br><span class="line">    Person p2 = getPerson (id2);</span><br><span class="line">    p1.addSocialValue (getMessage (id).getSocialValue ());</span><br><span class="line">    p2.addSocialValue (getMessage (id).getSocialValue ());</span><br><span class="line">    Message m = getMessage (id);</span><br><span class="line">    <span class="keyword">if</span> (m <span class="keyword">instanceof</span> RedEnvelopeMessage) &#123;</span><br><span class="line">        p1.addMoney (-((RedEnvImpl) m).getMoney ());</span><br><span class="line">        p2.addMoney (((RedEnvImpl) m).getMoney ());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m <span class="keyword">instanceof</span> EmojiMessage) &#123;</span><br><span class="line">        emojiHeatList.computeIfPresent (((EmojiMessage) m).getEmojiId (), (k, v) -&gt; v + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ((LinkedList&lt;Message&gt;) p2.getMessages ()).addFirst (m);</span><br><span class="line">    messages.remove (m.getId ());</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; distance = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    HashSet&lt;Person&gt; solved = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    PriorityQueue&lt;Person&gt; unsolved =</span><br><span class="line">            <span class="keyword">new</span> PriorityQueue&lt;&gt;(Comparator.comparingInt (o -&gt; distance.get (o.getId ())));</span><br><span class="line">    <span class="keyword">for</span> (Person p : people.values ()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.equals (p1)) &#123;</span><br><span class="line">            distance.put (p.getId (), p.queryValue (p1));</span><br><span class="line">            solved.add (p);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            distance.put (p.getId (), p.isLinked (p1) ? p.queryValue (p1) : Integer.MAX_VALUE);</span><br><span class="line">            unsolved.add (p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!unsolved.isEmpty ()) &#123;</span><br><span class="line">        <span class="comment">//find the closest vertex around S in (V - S)</span></span><br><span class="line">        Person closestPerson = unsolved.poll ();</span><br><span class="line">        solved.add (closestPerson);</span><br><span class="line">        <span class="comment">//refresh the vertices around closestPerson in (V - S)</span></span><br><span class="line">        <span class="keyword">for</span> (Person pp : ((PersonImpl) closestPerson).getAcquaintance ().values ()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (distance.get (pp.getId ()) &gt;</span><br><span class="line">                    distance.get (closestPerson.getId ()) + closestPerson.queryValue (pp) &amp;&amp;</span><br><span class="line">                    unsolved.contains (pp) &amp;&amp; !solved.contains (pp)) &#123;</span><br><span class="line">                unsolved.remove (pp);</span><br><span class="line">                distance.put (pp.getId (),</span><br><span class="line">                        distance.get (closestPerson.getId ()) + closestPerson.queryValue (pp));</span><br><span class="line">                unsolved.add (pp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> distance.get (id2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 初始状态为：<code>V = &#123;StartPoint&#125;, S = VertexSet - &#123;StartPoint&#125;</code>， 然后不断在 <code>S</code> 中寻找 ** 距离点集 <code>V</code> 最近的点 <code>P</code>**，将其从 <code>V</code> 中去掉并加入 <code>S</code>，更新所有 <code>S</code> 中点的距离后进入下一个循环直到 <code>S = &#123;&#125;</code>。这里有一个可以优化性能的点，那就是在更新 <code>S</code> 中其他点的距离时不需要便利所有点，只需要在 <code>P</code> 的邻居之间寻找即可，而在本次作业中每个人都记录了自己认识的人的集合，所以直接遍历这个集合并更新距离即可。最后的实验也证明了这样的效率是很高的。</p>
<p>##🎈本地测试数据</p>
<p>​ 在自己的本地测试中主要是随机生成的数据点，因为程序预先设计了许多异常，并有异常对应的特殊输出，所以数据点可以随机进行生成。主要是根据 <code>Random rand; int p = rand.nextInt ();</code> 给出的 <code>p</code> 值设置一些区间来生成数据。当然根据一些特定指令可以手写一些小规模的针对性测试点。</p>
<p>​ 在测试过程中我借用了室友的评测机进行对拍。据我所知，该评测机可以生成随机测试点和针对性测试点。针对性测试点主要是测试需要用到图论算法的指令（比如 <code>qgvs</code> 和 <code>sim</code> 等），生成一些极端的数据看是否会超时。</p>
<h2 id="性能问题和修复情况">🛰性能问题和修复情况</h2>
<h3 id="并查集出现-stackoverflow">1️⃣并查集出现 StackOverFlow</h3>
<p>​ 第一次作业并查集类中的 <code>find ()</code> 函数使用了路径压缩的方法，把每个被查询的点直接连接到其祖先。由于当时不清楚 <code>HashMap</code> 中的 <code>put ()</code> 方法遇到重复的键会直接改写，我使用了 <code>computeIfPresent ()</code> 方法来改写。这种处理方法会在函数迭代次数过多的情况下导致栈溢出的异常。</p>
<h3 id="qgvs-指令超时">2️⃣<code>qgvs</code> 指令超时</h3>
<p>​ <code>qgvs</code> 指令需要计算一个组当中每个人对其他人的社交值的和，计算一次的时间复杂度是 <span class="math inline">\(O (n^2)\)</span>，因此互测中可能会有人大量调用该指令来 hack。我首先想到的解决办法是在第一次调用 <code>qgvs k</code> 的时候将 <code>k</code> 组的对应值算出来并储存，然后之后每次调用的时候只需读取储存的值即可。当然在 <code>atg/dfg</code> 之后需要修改储存的值，需要将之前储存的值 <span class="math inline">\(val\)</span> 加上或减去 <span class="math inline">\(2\sum_{p \in P&#39;s\ acquaintance} SV_p\)</span>。但是在实现之后总是有 bug 并且我一直没有发现问题出在哪里，于是采用了一个拙劣的方法：维护一个 <code>private boolean modified</code> 来记录 “在上次 <code>qgvs</code> 并存储之后这个组的成员有没有被修改”（初始值为 <code>true</code>），这样如果连续 <code>qgvs</code> 轰炸就不用重新计算。当然如果边修改组内成员边 <code>qgvs</code> 则还是有超时的可能，这也是迫不得已的方法。</p>
<h2 id="network-拓展-jml">🚀<code>Network</code> 拓展 JML</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/*@ public normal_behavior</span></span><br><span class="line"><span class="comment">	@ ensure</span></span><br><span class="line"><span class="comment">	@ (\exist i; 0 &lt;= i &amp;&amp; i &lt; advertisers.length;advertisers [i].isLinked (getMessage (id).getPerson2 ())) &amp;&amp; advertisers [i].isLinked (getMessage (id).getPerson1 ()))</span></span><br><span class="line"><span class="comment">	@ assignable getMessage (id).getPerson2 ().messages</span></span><br><span class="line"><span class="comment">	@ ensures getMessage (id).getPerson2 ().messages.length = (getMessage (id).getPerson2 ().messages.length) + 1 </span></span><br><span class="line"><span class="comment">	@ ensures (\forall int i; 0 &lt;= i &amp;&amp; i &lt; \old (getMessage (id).getPerson2 ().getMessages ().size ());</span></span><br><span class="line"><span class="comment">	@          \old (getMessage (id)).getPerson2 ().getMessages ().get (i+1) == \old (getMessage (id).getPerson2 ().getMessages ().get (i)));</span></span><br><span class="line"><span class="comment">	@ ensures \old (getMessage (id)).getPerson2 ().getMessages ().get (0).equals (\old (getMessage (id)));</span></span><br><span class="line"><span class="comment">	@ assignable getMessage (id).getPerson2 ().money</span></span><br><span class="line"><span class="comment">	@ getMessage (id).getPerson2 ().money = \old (getMessage (id).getPerson2 ().money) + getMessage (id).getsocialValue ()</span></span><br><span class="line"><span class="comment">	@ ensures &amp;!containsMessage (id) &amp;&amp; messages.length == \old (messages.length) - 1 &amp;</span></span><br><span class="line"><span class="comment">	@         (\forall int i; 0 &lt;= i &amp;&amp; i &lt; \old (messages.length) &amp;&amp; \old (messages [i].getId ()) != id;</span></span><br><span class="line"><span class="comment">	@         (\exists int j; 0 &lt;= j &amp;&amp; j &lt; messages.length; messages [j].equals (\old (messages [i]))));</span></span><br><span class="line"><span class="comment">	@ also</span></span><br><span class="line"><span class="comment">	@ public exceptional_behavior</span></span><br><span class="line"><span class="comment">	@ signals (PersonIdNotFoundException e) </span></span><br><span class="line"><span class="comment">	@ (\forall i; 0 &lt;= i &amp;&amp; i &lt; customers.length;!customers [i].equals (getMessage (id).getPerson1 ())) ||</span></span><br><span class="line"><span class="comment">	@ (\forall i; 0 &lt;= i &amp;&amp; i &lt; producers.length;!producers [i].equals (getMessage (id).getPerson2 ()))</span></span><br><span class="line"><span class="comment">	@ signals (RelationNotFoundException e) </span></span><br><span class="line"><span class="comment">	@ (\forall i; 0 &lt;= i &amp;&amp; i &lt; advertisers.length;!advertisers [i].isLinked (getMessage (id).getPerson2 ())) || !advertisers [i].isLinked (getMessage (id).getPerson1 ()))</span></span><br><span class="line"><span class="comment">	@*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">purchase</span><span class="params">(<span class="keyword">int</span> personID)</span> <span class="keyword">throws</span> PersonIdMotFoundException, RelationNotFoundException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*@ public normal_behavior</span></span><br><span class="line"><span class="comment">  @ requires contains (ads.getProducer ()) &amp;&amp; contains (ads.getAdvertiser ());</span></span><br><span class="line"><span class="comment">  @ assignable people [*].money, ((Producer) people [*]).sales;</span></span><br><span class="line"><span class="comment">  @ ensures (\forall int i;0 &lt;= i &amp;&amp; i &lt; people.length;</span></span><br><span class="line"><span class="comment">  @          (people [i] instanceof Producer &amp;&amp; ads.getProducer ().getId == people [i].getId ()) ==&gt;</span></span><br><span class="line"><span class="comment">  @           people [i].money = \old (people [i].getMoney ()) - (ads.getCost ()) +</span></span><br><span class="line"><span class="comment">  @           (\sum int j;0 &lt;= j &amp;&amp; j &lt; people.length &amp;&amp; people [j] instanceof Consumer &amp;&amp; ((Consumer) people [j]).wantsToBuy (ads.getProduct ());</span></span><br><span class="line"><span class="comment">  @            ads.getPrice ())));</span></span><br><span class="line"><span class="comment">  @ ensures (\forall int i;0 &lt;= i &amp;&amp; i &lt; people.length;</span></span><br><span class="line"><span class="comment">  @          (people [i] instanceof Producer &amp;&amp; ads.getProducer ().getId == people [i].getId ()) ==&gt;</span></span><br><span class="line"><span class="comment">  @           ((Producer) people [i]).sales = \old (((Producer) people [i]).getSales ()) + </span></span><br><span class="line"><span class="comment">  @           (\sum int j;0 &lt;= j &amp;&amp; j &lt; people.length &amp;&amp; people [j] instanceof Consumer &amp;&amp; ((Consumer) people [j]).wantsToBuy (ads.getProduct ());</span></span><br><span class="line"><span class="comment">  @            1)));</span></span><br><span class="line"><span class="comment">  @ ensures (\forall int i;0 &lt;= i &amp;&amp; i &lt; people.length;</span></span><br><span class="line"><span class="comment">  @          (people [i] instanceof Advertiser &amp;&amp; ads.getAdvertiser ().getId () == people [i].getId ()) ==&gt;</span></span><br><span class="line"><span class="comment">  @           people [i].money = \old (people [i].getMoney ()) + ads.getCost ());</span></span><br><span class="line"><span class="comment">  @ ensures (\forall int i;0 &lt;= i &amp;&amp; i &lt; people.length;</span></span><br><span class="line"><span class="comment">  @          (people [i] instanceof Consumer &amp;&amp; people [i].wantsToBuy (ads.getProduct ())) ==&gt;</span></span><br><span class="line"><span class="comment">  @           people [i].money = \old (people [i].getMoney ()) - ads.getPrice ());</span></span><br><span class="line"><span class="comment">  @ ensures (\forall int i;0 &lt;= i &amp;&amp; i &lt; people.lenght;</span></span><br><span class="line"><span class="comment">  @          !(people [i] instanceof Producer || people [i] instanceof Consumer || people [i] instanceof Advertiser) ==&gt;</span></span><br><span class="line"><span class="comment">  @           \not_assigned (people [i].money));</span></span><br><span class="line"><span class="comment">  @ also</span></span><br><span class="line"><span class="comment">  @ public exceptional_behavior</span></span><br><span class="line"><span class="comment">  @ signals (ProducerNotFoundException e) !contains (ads.getProducer ()) ||</span></span><br><span class="line"><span class="comment">  @                                       (contains (ads.getProducer ()) &amp;&amp; !(getPerson (ads.getProducer ()) instacnceof Producer));</span></span><br><span class="line"><span class="comment">  @ also</span></span><br><span class="line"><span class="comment">  @ public exceptional_behavior</span></span><br><span class="line"><span class="comment">  @ signals (AdvertiserNotFoundException e) contains (ads.getProducer ()) &amp;&amp; getPerson (ads.getProducer () instacnceof Producer)) &amp;&amp;</span></span><br><span class="line"><span class="comment">  @                                         (!contains (ads.getProducer ()) ||</span></span><br><span class="line"><span class="comment">  @                                          (contains (ads.getProducer ()) &amp;&amp; !(getPerson (ads.getProducer ()) instacnceof Producer)));</span></span><br><span class="line"><span class="comment">  @*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishAdvertisement</span><span class="params">(Advertisement advertisement)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">    ProducerNotFoundException, AdvertiserNotFoundException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*@ public normal_behavior</span></span><br><span class="line"><span class="comment">	@ requires containsProductId (productId);</span></span><br><span class="line"><span class="comment">	@ ensures \result == productList (id).getSalesAmount ();</span></span><br><span class="line"><span class="comment">	@ also</span></span><br><span class="line"><span class="comment">	@ public exceptional_behavior</span></span><br><span class="line"><span class="comment">	@ signals (ProductNotFoundException e) !containsProduct (productId);</span></span><br><span class="line"><span class="comment">	@*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">querySaleAmount</span><span class="params">(<span class="keyword">int</span> productId)</span> <span class="keyword">throws</span> ProductNotFoundException； </span></span><br></pre></td></tr></table></figure>
<h2 id="心得与体会">🤔心得与体会</h2>
<p>​ 第三单元是互测的最后一个单元，本学期的圣杯战争终于告一段落。<del>（悲）</del></p>
<p>​ 本单元作业相比前两个单元确实要简单一些，如果不写评测机和测试点生成程序的话基本上没有什么压力。对于大部分函数来说只要跟着 JML 写就可以（大概）保证正确性，一些需要考虑图论算法和 JML 很长的函数也不会带来很大负担。不过由于 JML 的复杂性，有一些细节很容易被遗漏，所以这个单元比前两个单元更容易出 bug。好在课程组好心没有在强测中出极端数据，这样我的两个 bug 没有影响到强测😀。</p>
<p>​ 助教说这单元的重点是阅读 JML 并给出能保证正确性的代码实现，而不是算法。个人感觉也是如此，算法超时造成的损失一定比遗漏某些细节造成的损失大，但是实现算法的过程比阅读 JML 要有趣很多（划）。说到底也是个 tradeoff 吧，契约式编程能够保证程序实现的正确性，不存在自然语言的多义性，但是读懂并理解 JML 的含义并不是轻松的工作，比如求最小生成树函数的 JML 就非常长，而且 JML 所表述的内容很抽象，完全理解需要来来回回读好几遍。个人感觉 JML 在一些情况下可能会浪费时间：还是上面的例子，需求者可以直接传达 “求组内包含某个点的最小生成树” 的信息，这样比 JML 要便捷许多，也不用花费心思用数组来抽象树的结构，在编写和理解两端都要耗费不少精力。当然在大多数环境下为了保证代码严格的正确性，以及完整严谨地传达用户的请求（据荣文戈老师所言，用户是很可怕的😱），还是有必要进行契约式编程的。</p>
]]></content>
      <tags>
        <tag>BUAA OO</tag>
      </tags>
  </entry>
  <entry>
    <title>BUAA OO U4 Review</title>
    <url>/2022/10/21/BUAA-OO-U4-Review/</url>
    <content><![CDATA[<h1 id="buaa-oo-第四单元总结-课程总结">BUAA OO 第四单元总结 &amp; 课程总结</h1>
<h2 id="概述">🖊概述</h2>
<p>​ 本单元的目标是在课程组提供的 UML 解析程序基础之上，封装自己的 UML 元素类来建模、指令查询和抛出异常等。在此之前需要熟悉 UML 类图、顺序图和状态图各个元素之间的基本关系，以便建立恰当的模型。</p>
<h2 id="架构设计">🗺架构设计</h2>
<p><img src="/2022/10/21/BUAA-OO-U4-Review/image-20220623165433835.png" alt="封装的类图" style="zoom:60%;"></p>
<p><img src="/2022/10/21/BUAA-OO-U4-Review/image-20220623165613658.png" alt="整体架构" style="zoom:80%;"></p>
<p>​ 三次作业是增量开发的关系，每次作业在之前的基础上添加新的功能（新的查询指令或者抛出异常），总体难度较低，但是工作量不小，需要兼顾到整体设计架构的简洁性和实现功能的正确性。</p>
<p>​ 其中有三个类（<code>ClassDiagram</code>、<code>SequenceDiagram</code>、<code>StateDiagram</code>）是工具类，包含一些静态方法供 <code>UserApiImpl</code> 调用，否则会超行数😀。另外为了建模方便，构造方法中给出的 <code>UmlElement</code> 的顺序不一定满足需要，因为有些元素需要提前处理，所以在开始的时候我进行了排序，部分代码片段如下。（选择 <code>.stream ().sorted ()</code> 的原因是 <code>UmlMessage</code> 在列表中是按顺序排好的，需要保证排序的稳定性，因此不能使用普通的 <code>.sort ()</code>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">elementWeight</span><span class="params">(UmlElement e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (e <span class="keyword">instanceof</span> UmlClass ||</span><br><span class="line">            e <span class="keyword">instanceof</span> UmlStateMachine ||</span><br><span class="line">            e <span class="keyword">instanceof</span> UmlCollaboration) ? <span class="number">0</span> :</span><br><span class="line">            (e <span class="keyword">instanceof</span> UmlInterface ||</span><br><span class="line">                e <span class="keyword">instanceof</span> UmlRegion ||</span><br><span class="line">                    e <span class="keyword">instanceof</span> UmlInteraction) ? <span class="number">1</span> :</span><br><span class="line">                    (e <span class="keyword">instanceof</span> UmlOperation ||</span><br><span class="line">                        e <span class="keyword">instanceof</span> UmlPseudostate ||</span><br><span class="line">                            e <span class="keyword">instanceof</span> UmlState ||</span><br><span class="line">                            e <span class="keyword">instanceof</span> UmlFinalState ||</span><br><span class="line">                            e <span class="keyword">instanceof</span> UmlLifeline ||</span><br><span class="line">                            e <span class="keyword">instanceof</span> UmlEndpoint) ? <span class="number">2</span> :</span><br><span class="line">                            (e <span class="keyword">instanceof</span> UmlTransition) ? <span class="number">3</span> :</span><br><span class="line">                                    (e <span class="keyword">instanceof</span> UmlParameter ||</span><br><span class="line">                                            e <span class="keyword">instanceof</span> UmlEvent ||</span><br><span class="line">                                            e <span class="keyword">instanceof</span> UmlMessage ||</span><br><span class="line">                                            e <span class="keyword">instanceof</span> UmlAssociation) ? <span class="number">4</span> : <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UserApiImpl</span><span class="params">(UmlElement... elements)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;UmlElement&gt; elementList = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList (elements));</span><br><span class="line">    elementList = (ArrayList&lt;UmlElement&gt;) elementList.stream ()</span><br><span class="line">            .sorted (Comparator.comparing (<span class="keyword">this</span>::elementWeight))</span><br><span class="line">            .collect (Collectors.toList ());</span><br><span class="line">    <span class="comment">// HANDLE UMLELEMENTS</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="设计思维和-oo-理解演进">🏃‍♀️设计思维和 OO 理解演进</h2>
<h3 id="第一单元">第一单元</h3>
<p>​ 经过了假期的 Pre 训练，我对 Java 语法和面向对象有了初步的认识，但还是被第一单元难住了。（x</p>
<p>​ 第一单元中最重要的一步是抽象表达式元素的结构和相互之间的关系，比如三角函数如何存储、如何找到表达式计算的好方法等等问题都是必须考虑的。第一次作业因为没有引入其他函数和变量，因此一个 <code>HashMap&lt;Integer, Integer&gt;</code> 完全可以胜任，但是在后续的作业中就不得不重构了，遗憾的是我当时没有在找到一个合适的结构，导致三次作业中完全没有继承关系 + 一些类中的方法很臃肿，有的方法甚至套了七八层大括号（幸好只有三次作业😀）。</p>
<p>​ 幸运的是在第一单元中我深刻认识到面向对象编程思想和设计模式的重要性，在之后的作业中加以注意，没有犯类似的错误。</p>
<h3 id="第二单元">第二单元</h3>
<p>​ 第二单元中我第一次接触到 Java 多线程的相关知识，在入门的时候花了很多时间来学习和构思。最终大概思路是构建一个或若干个线程安全类，其实例作为线程之间的 “桥梁”，每个线程之间的逻辑是相对独立的。细节方面主要是注意锁的使用和 <code>synchronized</code> 块的范围（我就因此在第一次作业中出现了 bug），以及消除轮询。因为第一次作业建立了一个还算合理的架构和电梯调度的算法（后面就没有动过，LOL），所以后面两次作业就比较顺利，线程之间如何沟通、同步等等都比较熟练，代码的逻辑性和条理性也得到了提升。</p>
<h3 id="第三单元">第三单元</h3>
<p>​ 第三单元学习了 JML 语言体系并且初步接触了契约式编程，主要是根据给定的规格来构造社交网络并实现特定的功能。简单来说就是给定一个框架，包括条件、结果和影响等等，如何实现还是见仁见智。在第三单元中我学习了契约式编程的实现和相关细节，并且复习了一些图论算法，整体工作量上比前两个单元要少很多。</p>
<h3 id="第四单元">第四单元</h3>
<p>​ 第四单元主要是建立 UML 的模型并实现查询和抛出异常等功能。总体难度不大，重点是要熟悉 UML 类图、顺序图和状态图各个元素之间的关系。需要注意的是要仔细阅读指导书，完全理解功能的含义再着手写代码，否则很可能会出现 bug。</p>
<h2 id="测试实践的演进">✔测试实践的演进</h2>
<h3 id="第一单元-1">第一单元</h3>
<p>​ 第一单元的测试主要基于手动构造样例的形式展开，给出若干个比较长的数据点并和结果进行比较。其中比较的过程我借助了 <code>Mathematica</code> 的工具来验证，比如统一代入 1 比较结果即可。由于两个不恒等的表达式代入之后误差小于阈值的可能性极小，因此这种验证方法还算可靠。当然也可以使用 python 的相关库来实现。</p>
<h3 id="第二单元-1">第二单元</h3>
<p>​ 第二单元的测试也是基于手动构造样例的形式，可以构造很极端的数据（比如第 69.9 秒的时候突然增加若干请求来测试高并发情况下的正确性）。在线程轮询的排除方面我使用了 <code>jcommander</code> 来跟踪程序运行的各种状态。除此之外我还使用了室友写的小程序，它可以将无序且杂乱的输出按照电梯的序号来一一整理，这样就能直接查看具体某一部电梯的运行状态，非常方便。</p>
<h3 id="第三单元-1">第三单元</h3>
<p>​ 第三单元个人感觉把指导书上每个细节都注意到就基本上不会有太大问题，主要还是性能方面可能会造成 bug。在写算法的时候要注意复杂度和函数调用栈等等，总之要时刻注意可能出现的超时问题，~~ 因为互测大家都是用极端数据炸人～～。测试方面我只写了一个测试极端数据的数据生成器，主要还是靠和室友对拍来验证。</p>
<h3 id="第四单元-1">第四单元</h3>
<p>​ 第四单元和第三单元类似，搞清楚指导书并把讨论区的问题过一遍可以帮助排除一些 bug，当然最好还是从头到尾把自己写的程序逻辑过一遍（可以自己给自己讲讲实现的思路，也许会找到 bug 也说不定）。第三次作业的压缩包里给出了每个异常对应的 UML 图，把这些都验证一遍就可以排除很多 bug。</p>
<h2 id="课程收获">🙌课程收获</h2>
<p>​ 这一学期的课程下来，最直接的收获当然是体会了解并内化了面向对象的思想和一些设计模式，逐渐抛弃了一些面向过程编程的小毛病，写出来的代码更优雅、可读性更强了（checkstyle 插件功不可没，逃）。</p>
<p>​ 除此之外一个让我明显感觉到的收获是：不怕写代码了。如果说上学期的计组还是我对码代码脱敏的预备期，那么这学期经过 OO 和 OS 的双重考验，我想我对写代码这件事已经没有了大一时候隐隐的恐惧。每次作业动辄上千行代码和重构的经历使我在思考代码本身的同时必须兼顾到整个架构的合理性和复杂度，这些都是写代码必备的能力，会很多算法和编程技巧是一方面，拥有架构设计和组织的能力并应用到实际编程当中也是很重要的。</p>
<h2 id="一些小建议">💫一些小建议</h2>
<ol type="1">
<li>多线程的相关知识可以提前下放，比如在预习任务里稍微涉及一点点，或者干脆让第二单元多一次作业并砍掉第三或者第四单元的一次作业。本学期第二单元第一次作业因为假期而延长了几天时间，这几天时间刚刚好让我熟悉了多线程的知识并理清楚了思路，不知道是不是每学期第二单元都恰巧能赶上一次假期🤔。</li>
<li>关于研讨课，个人认为安排不够合理：一方面留给小组讨论和展示的时间比较仓促；一方面在某些讨论题下大家得出的结论可能是比较相似的，上台展示内容的重合度也比较高，这样一来大家的收获相比花掉的时间来说会相对减少。可以适当延长一些讨论的时间并减少上台展示的人数，比如可以等讨论结束抽签一些组来展示，这样大家都有足够的机会参与到讨论当中，也给展示环节减少了负担（个人经验是几乎没有哪次可以所有组都讲完的）。然后课下可以所有人维护一个讨论课总结文档，每一组把讨论的结果写进去，这样也给没有展示的小组补充观点的机会，deadline 过了之后再整合一下文档发给同学阅读。这学期的研讨课感觉课上大家整体参与度不是太高，课下总结文档提交完问卷星就石沉大海，这两方面都可以提高一些效率。</li>
<li>互测阶段可以开放 star 的功能。如果看到同房间有同学的代码写得比较优雅，可以 star 标记一下，在本单元结束之后公布一下这些同学的代码供同学们学习。然后同房间被 star 最多的同学可以在互测或者强测环节酌情加分（或者扣分减免）🤔？也许互测可以增加 “star 一位同学的代码” 的要求，并且需要下载所有代码之后才可以 star，这样也符合互测的目的，哪怕不肉眼 debug 其他同学的代码，看看其他实现方法也是好的（感觉大多数同学到后面就是直接造数据 hack 一个算一个）。只是一个初步的想法，为了保证平衡性可能还有很多细节要实现。</li>
</ol>
]]></content>
      <tags>
        <tag>BUAA OO</tag>
      </tags>
  </entry>
  <entry>
    <title>「复分析」Chapter1：微积分</title>
    <url>/2021/12/07/%E5%A4%8D%E5%88%86%E6%9E%90Chapter1/</url>
    <content><![CDATA[<h2 id="一回顾">一、回顾</h2>
<h4 id="外微分形式r3">外微分形式（<span class="math inline">\(R^3\)</span>）</h4>
<ul>
<li><p><span class="math inline">\(\mathrm {d} x\)</span> 与 <span class="math inline">\(\mathrm {d} y\)</span> 外乘积记作 <span class="math inline">\(\mathrm {d} x∧\mathrm {d} y\)</span>，且有关系 <span class="math inline">\(\mathrm {d} x∧\mathrm {d} y=-\mathrm {d} y∧\mathrm {d} x\)</span>.</p></li>
<li><p>对外微分形式 <span class="math inline">\(\omega\)</span> 定义微分算子 <span class="math inline">\(\mathrm {d}\)</span>，则有：</p></li>
</ul>
<h5 id="omegaf-rightarrow-mathrm-domegafrac-partial-fpartial-xmathrm-d-xfrac-partial-fpartial-ymathrm-d-yfrac-partial-fpartial-zmathrm-d-z"><span class="math inline">\(①\omega=f \rightarrow \mathrm {d}\omega=\frac {\partial f}{\partial x}\mathrm {d} x+\frac {\partial f}{\partial y}\mathrm {d} y+\frac {\partial f}{\partial z}\mathrm {d} z\)</span></h5>
<h5 id="begin-split②omegasumlimits_cyc-amathrm-d-ywedge-mathrm-d-z-rightarrow-mathrm-domegasumlimits_cyc-frac-partial-apartial-xmathrm-d-xwedge-mathrm-d-ywedge-mathrm-d-zend-split"><span class="math inline">\(\begin {split}②&amp;\omega=\sum\limits_{cyc} A\mathrm {d} y\wedge \mathrm {d} z \\&amp;\Rightarrow \mathrm {d}\omega=(\sum\limits_{cyc} \frac {\partial A}{\partial x})\mathrm {d} x\wedge \mathrm {d} y\wedge \mathrm {d} z\end {split}\)</span></h5>
<h5 id="begin-split③-omega-pmathrm-d-xqmathrm-d-yrmathrm-d-zrightarrow-mathrm-domegasumlimits_cycfrac-partial-rpartial-y-frac-partial-qpartial-zmathrm-d-ymathrm-d-z-end-split"><span class="math inline">\(\begin {split}③\ &amp;\omega =P\mathrm {d} x+Q\mathrm {d} y+R\mathrm {d} z\\&amp;\Rightarrow \mathrm {d}\omega=\sum\limits_{cyc}(\frac {\partial R}{\partial y}-\frac {\partial Q}{\partial z})\mathrm {d} y∧\mathrm {d} z \end {split}\)</span></h5>
<h5 id="omega-h-mathrm-d-xwedgemathrm-d-ywedgemathrm-d-zrightarrowmathrm-domega0"><span class="math inline">\(④\omega = H \mathrm {d} x\wedge\mathrm {d} y\wedge\mathrm {d} z\Rightarrow\mathrm {d}\omega=0\)</span></h5>
<ul>
<li><p><span class="math inline">\((Poincare\ Lemma)\)</span>​ <span class="math inline">\(\omega\)</span>​是外微分形式且系数有二阶连续偏导等价于 <span class="math inline">\(\mathrm {d}\mathrm {d}\omega=0\)</span>​.（即若 <span class="math inline">\(p\)</span>​次外微分形式 <span class="math inline">\(\omega\)</span>​有 <span class="math inline">\(\mathrm {d}\omega=0\)</span>​则存在 <span class="math inline">\(p-1\)</span>​次外微分形式 <span class="math inline">\(\alpha\)</span>​使得 <span class="math inline">\(\omega=\mathrm {d}\alpha\)</span>​）</p></li>
<li><p>统一 <span class="math inline">\(Green、Gauss、Stokes\)</span>​公式：<span class="math display">\[\begin {align}\int_{\partial\Sigma}\ \omega=\int_{\Sigma}\ \mathrm {d}\omega\end {align}\]</span>.​</p></li>
</ul>
<h2 id="二复微分">二、复微分</h2>
<ul>
<li><span class="math inline">\(f:\mathbb {C}\rightarrow\mathbb {C}\)</span>​，导数定义类似。若 <span class="math inline">\(f (z)\)</span>​在定义域上每一点可微，则称 <span class="math inline">\(f\)</span>​ 解析或全纯.</li>
<li><span class="math inline">\((Cauchy-Riemann)\)</span>​ 若 <span class="math inline">\(f (z)=u (x,y)+iv (x,y)\)</span>​在 <span class="math inline">\(z_{0}=x_{0}+iy_{0}\)</span>​处可微，则有</li>
</ul>
<p><span class="math display">\[
\begin {align} f&#39;(z_{0})&amp;=u&#39;_{x}(x_{0},y_{0})+iv&#39;_{x}(x_{0},y_{0})\\&amp;=v&#39;_{y}(x_{0},y_{0})-iu&#39;_{x}(x_{0},y_{0})\end {align}
\]</span></p>
<p>，由此立即推出： <span class="math display">\[
\begin {aligned}\frac {\partial f}{\partial x}+i\frac {\partial f}{\partial y}=0\ or\left\{\begin {matrix} u&#39;_{x}=v&#39;_{y}\\u&#39;_{y}=-v&#39;_{x}\end {matrix}\right.\end {aligned}
\]</span></p>
<ul>
<li><p><span class="math inline">\(f (z)=u+iv\)</span> 在 <span class="math inline">\(D\)</span> 内全纯 <span class="math inline">\(\Leftrightarrow\)</span><span class="math inline">\(u,v\)</span> 在 <span class="math inline">\(D\)</span> 内有一阶连续偏微商且满足 <span class="math inline">\(Cauchy-Riemann\)</span> 条件.</p></li>
<li><p>事实上，如果 <span class="math inline">\(f (z)=u+iv\)</span>​在 <span class="math inline">\(D\)</span>​内全纯，则 <span class="math inline">\(f&#39;(z)\)</span>​也在 <span class="math inline">\(D\)</span>​内全纯，由此得到 <span class="math inline">\(\Delta u=\Delta v=0\)</span>​.</p></li>
<li><p>引入记号： <span class="math display">\[
\left\{
\begin {align}
\frac {\partial}{\partial z}=\frac {1}{2}(\frac {\partial}{\partial x}-i\frac {\partial}{\partial y})\\
\frac {\partial}{\partial \bar {z}}=\frac {1}{2}(\frac {\partial}{\partial x}+i\frac {\partial}{\partial y})
\end {align}.
\right.
\]</span></p></li>
</ul>
<p>则 <span class="math inline">\(f\)</span> 全纯 <span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\(\begin {align}\frac {\partial f}{\partial \bar {z}}=0\end {align}\)</span>，同时 <span class="math inline">\(\begin {align}\Delta =4\frac {\partial^2}{\partial z\partial \bar {z}}=4\frac {\partial^2}{\partial \bar {z}\partial z}\end {align}\)</span>.</p>
<ul>
<li><span class="math inline">\(\begin {align}\mathrm {d} f=\frac {\partial f}{\partial x}\mathrm {d} x+\frac {\partial f}{\partial y}\mathrm {d} y=\frac {\partial f}{\partial z}\mathrm {d} z+\frac {\partial f}{\partial \bar {z}}\mathrm {d}\bar {z} \end {align}\)</span>， 记 <span class="math inline">\(\begin {align}\partial f=\frac {\partial f}{\partial z}\mathrm {d} z,\bar {\partial} f=\frac {\partial f}{\partial \bar {z}}\mathrm {d}\bar {z} \end {align}\)</span>，则 <span class="math inline">\(\mathrm {d}=\partial+\bar {\partial}\)</span>.</li>
<li>（共形性）设 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(D\)</span> 全纯，<span class="math inline">\(z_0\in D\)</span> 且 <span class="math inline">\(f&#39;(z_0)\neq0\)</span>，曲线 <span class="math inline">\(\gamma\)</span> 满足 <span class="math inline">\(\gamma (t)\ (0\leq t\leq1)\)</span> 在 <span class="math inline">\(D\)</span> 内过 <span class="math inline">\(z_0\)</span> 且 <span class="math inline">\(\gamma (0)=z_0\)</span>，<span class="math inline">\(\gamma (t)\)</span> 在 <span class="math inline">\(z_0\)</span> 处和实轴的夹角为 <span class="math inline">\(arg\ \gamma&#39;(t)\)</span>，<span class="math inline">\(f\)</span> 把 <span class="math inline">\(\gamma\)</span> 映射成曲线 <span class="math inline">\(\sigma (t)=f (\gamma (t))\)</span>，则 <span class="math inline">\(\sigma&#39;(t)=\gamma&#39;(t) f&#39;(\gamma (t))\)</span>，因此 <span class="math inline">\(arg\ f&#39;(z_0)=arg\ \sigma&#39;(0)-arg\ \gamma&#39;(0)\)</span><strong>（保角性）</strong>. 另外，有 <span class="math inline">\(\begin {align}\frac {\vert {f (z)-f (z_0)}\vert}{\vert z-z_0\vert}=\frac {\vert\omega-\omega_0\vert}{\vert z-z_0\vert}\rightarrow\vert f&#39;(z_0)\vert (z\rightarrow z_0,z\in \gamma) \end {align}\)</span>.</li>
</ul>
<h2 id="三复积分">三、复积分</h2>
<ul>
<li><p><span class="math inline">\(\begin {align} f=u+iv\Rightarrow\int f (t)\mathrm {d} t=\int u (t)\mathrm {d} t+i\int v (t)\mathrm {d} t \end {align}.\)</span></p></li>
<li><p>若 <span class="math inline">\(\gamma\)</span> 可求长，则：<span class="math inline">\(\begin {align}\int_\gamma f (z)\mathrm {d} z=\int_\gamma (u+iv)(\mathrm {d} x+i\mathrm {d} y) \end {align}.\)</span></p></li>
<li><p>复外微分形式：<span class="math inline">\(\mathrm {d}\bar {z} \wedge \mathrm {d} z=2i\mathrm {d} x\wedge\mathrm {d} y=2i\mathrm {d} A.\)</span></p></li>
<li><p>复形式的 Green 公式：若 <span class="math inline">\(\omega=\omega_1\mathrm {d} z+\omega_2\mathrm {d} z\)</span> 为 <span class="math inline">\(\Omega\)</span> 上的一次外微分算子，<span class="math inline">\(\omega_1,\omega_2\)</span> 为 <span class="math inline">\(z,\bar {z}\)</span> 的可微函数，则有 <span class="math inline">\(\begin {align}\int_{\partial \Omega}\omega=\iint_\Omega \mathrm {d}\omega \end {align}.\)</span></p></li>
</ul>
]]></content>
      <tags>
        <tag>复分析</tag>
      </tags>
  </entry>
</search>
